// This file is auto-generated by build.js
const HTML_CONTENT = "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Jack's Weather Forecast</title>\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\">\n    <link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/apple-touch-icon.png?v=e0bc3a4d\">\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n    <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\">\n    <meta name=\"apple-mobile-web-app-title\" content=\"Jack's Weather\">\n    <meta property=\"og:title\" content=\"Jack's Weather Forecast\">\n    <meta property=\"og:description\" content=\"Real-time weather forecasts with radar, hourly and daily forecasts\">\n    <meta property=\"og:type\" content=\"website\">\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js\"></script>\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css\">\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://unpkg.com/leaflet.wms@0.2.0/dist/leaflet.wms.js\"></script>\n    <style>\n        body {\n            background: #374151;\n            min-height: 100vh;\n        }\n        .weather-card {\n            backdrop-filter: blur(10px);\n            background: rgba(255, 255, 255, 0.1);\n        }\n        .loading {\n            display: inline-block;\n            width: 20px;\n            height: 20px;\n            border: 3px solid rgba(255,255,255,.3);\n            border-radius: 50%;\n            border-top-color: #fff;\n            animation: spin 1s ease-in-out infinite;\n        }\n        @keyframes spin {\n            to { transform: rotate(360deg); }\n        }\n        .modal {\n            display: none;\n            position: fixed;\n            z-index: 1000;\n            left: 0;\n            top: 0;\n            width: 100%;\n            height: 100%;\n            overflow: auto;\n            background-color: rgba(0,0,0,0.7);\n            backdrop-filter: blur(5px);\n        }\n        .modal.active {\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        .modal-content {\n            background: rgba(107, 114, 128, 0.95);\n            backdrop-filter: blur(20px);\n            margin: auto;\n            padding: 0;\n            border: 1px solid rgba(255,255,255,0.2);\n            border-radius: 1rem;\n            width: 90%;\n            max-width: 900px;\n            max-height: 90vh;\n            overflow-y: auto;\n            animation: modalSlideIn 0.3s ease-out;\n        }\n        @keyframes modalSlideIn {\n            from {\n                opacity: 0;\n                transform: translateY(-50px);\n            }\n            to {\n                opacity: 1;\n                transform: translateY(0);\n            }\n        }\n        .clickable {\n            cursor: pointer;\n            transition: transform 0.2s, background 0.2s;\n        }\n        .clickable:hover {\n            transform: scale(1.05);\n            background: rgba(255, 255, 255, 0.15) !important;\n        }\n        #radarMap {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body class=\"p-4 md:p-8\">\n    <div class=\"max-w-6xl mx-auto\">\n        <!-- Header -->\n        <div class=\"text-center mb-8\">\n            <h1 class=\"text-4xl md:text-5xl font-bold text-white mb-2\">\n                <i class=\"fas fa-cloud-sun mr-3\"></i>Jack's Weather Forecast\n            </h1>\n            <p class=\"text-white/80\">Powered by Open-Meteo & National Weather Service</p>\n        </div>\n\n        <!-- Weather Alerts -->\n        <div id=\"weatherAlerts\" class=\"hidden mb-6 max-w-6xl mx-auto space-y-3\">\n            <!-- Alerts will be inserted here -->\n        </div>\n\n        <!-- Search Bar -->\n        <div class=\"mb-6 px-2\">\n            <div class=\"flex flex-wrap gap-2 max-w-2xl mx-auto\">\n                <input \n                    type=\"text\" \n                    id=\"locationInput\" \n                    placeholder=\"Search for a city or location...\"\n                    class=\"flex-1 min-w-[200px] px-4 py-3 rounded-lg bg-white/20 backdrop-blur-sm text-white placeholder-white/60 border border-white/30 focus:outline-none focus:ring-2 focus:ring-white/50\"\n                >\n                <div class=\"flex gap-2\">\n                    <button \n                        id=\"searchBtn\"\n                        class=\"px-4 md:px-6 py-3 bg-white/20 hover:bg-white/30 backdrop-blur-sm rounded-lg text-white font-semibold transition-all border border-white/30\"\n                    >\n                        <i class=\"fas fa-search\"></i>\n                    </button>\n                    <button \n                        id=\"locationBtn\"\n                        class=\"px-4 md:px-6 py-3 bg-white/20 hover:bg-white/30 backdrop-blur-sm rounded-lg text-white font-semibold transition-all border border-white/30\"\n                        title=\"Use current location\"\n                    >\n                        <i class=\"fas fa-location-arrow\"></i>\n                    </button>\n                    <div class=\"relative\">\n                        <button \n                            id=\"favoritesBtn\"\n                            class=\"px-4 md:px-6 py-3 bg-white/20 hover:bg-white/30 backdrop-blur-sm rounded-lg text-white font-semibold transition-all border border-white/30\"\n                            title=\"Favorites\"\n                        >\n                            <i class=\"fas fa-star\"></i>\n                        </button>\n                        <div id=\"favoritesDropdown\" class=\"hidden absolute right-0 mt-2 w-64 bg-gray-700/95 backdrop-blur-sm rounded-lg border border-white/30 shadow-xl z-50 max-h-96 overflow-y-auto\">\n                            <div class=\"p-3 border-b border-white/20\">\n                                <div class=\"flex items-center justify-between\">\n                                    <h3 class=\"text-white font-semibold\">Favorites</h3>\n                                    <button id=\"addFavoriteBtn\" class=\"text-white/70 hover:text-white text-sm\">\n                                        <i class=\"fas fa-plus mr-1\"></i>Add Current\n                                    </button>\n                                </div>\n                            </div>\n                            <div id=\"favoritesList\" class=\"p-2\">\n                                <!-- Favorites will be inserted here -->\n                            </div>\n                            <div id=\"noFavorites\" class=\"p-4 text-white/60 text-sm text-center hidden\">\n                                No favorites yet. Add your current location to get started.\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- Error Message -->\n        <div id=\"errorMessage\" class=\"hidden max-w-2xl mx-auto mb-4 p-4 bg-red-500/20 backdrop-blur-sm rounded-lg text-white border border-red-300/30\">\n            <i class=\"fas fa-exclamation-circle mr-2\"></i>\n            <span id=\"errorText\"></span>\n        </div>\n\n        <!-- Loading State -->\n        <div id=\"loading\" class=\"hidden text-center py-12\">\n            <div class=\"loading mx-auto mb-4\"></div>\n            <p class=\"text-white\">Loading weather data...</p>\n        </div>\n\n        <!-- Main Content -->\n        <div id=\"weatherContent\" class=\"hidden\">\n            <!-- Current Weather -->\n            <div class=\"weather-card rounded-2xl p-6 md:p-8 mb-6 border border-white/20 shadow-2xl\">\n                <div class=\"flex flex-col md:flex-row justify-between items-start md:items-center mb-6\">\n                    <div>\n                        <h2 id=\"currentLocation\" class=\"text-2xl md:text-3xl font-bold text-white mb-2\"></h2>\n                        <p id=\"currentDate\" class=\"text-white/80\"></p>\n                    </div>\n                    <div class=\"text-right mt-4 md:mt-0\">\n                        <div id=\"currentTemp\" class=\"text-5xl md:text-6xl font-bold text-white mb-2\"></div>\n                        <p id=\"currentCondition\" class=\"text-xl text-white/90\"></p>\n                    </div>\n                </div>\n                \n                <div class=\"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-7 gap-4 mt-6\">\n                    <div class=\"bg-white/10 rounded-lg p-4 backdrop-blur-sm\">\n                        <div class=\"text-white/70 text-sm mb-1\"><i class=\"fas fa-thermometer-half text-orange-300 mr-1\"></i>Feels Like</div>\n                        <div id=\"feelsLike\" class=\"text-2xl font-bold text-white\"></div>\n                    </div>\n                    <div class=\"bg-white/10 rounded-lg p-4 backdrop-blur-sm\">\n                        <div class=\"text-white/70 text-sm mb-1\"><i class=\"fas fa-tint text-blue-300 mr-1\"></i>Humidity</div>\n                        <div id=\"humidity\" class=\"text-2xl font-bold text-white\"></div>\n                    </div>\n                    <div class=\"bg-white/10 rounded-lg p-4 backdrop-blur-sm\">\n                        <div class=\"text-white/70 text-sm mb-1\"><i class=\"fas fa-wind text-gray-300 mr-1\"></i>Wind Speed</div>\n                        <div id=\"windSpeed\" class=\"text-2xl font-bold text-white\"></div>\n                    </div>\n                    <div class=\"bg-white/10 rounded-lg p-4 backdrop-blur-sm\">\n                        <div class=\"text-white/70 text-sm mb-1\"><i class=\"fas fa-sun text-yellow-300 mr-1\"></i>UV Index</div>\n                        <div id=\"uvIndex\" class=\"text-2xl font-bold text-white\"></div>\n                    </div>\n                    <div class=\"bg-white/10 rounded-lg p-4 backdrop-blur-sm\">\n                        <div class=\"text-white/70 text-sm mb-1\"><i class=\"fas fa-sun text-yellow-400 mr-1\"></i>Sunrise</div>\n                        <div id=\"sunrise\" class=\"text-xl font-bold text-white\"></div>\n                    </div>\n                    <div class=\"bg-white/10 rounded-lg p-4 backdrop-blur-sm\">\n                        <div class=\"text-white/70 text-sm mb-1\"><i class=\"fas fa-moon text-blue-300 mr-1\"></i>Sunset</div>\n                        <div id=\"sunset\" class=\"text-xl font-bold text-white\"></div>\n                    </div>\n                    <div id=\"airQualitySection\" class=\"bg-white/10 rounded-lg p-4 backdrop-blur-sm hidden\">\n                        <div class=\"text-white/70 text-sm mb-1\"><i class=\"fas fa-wind mr-1\"></i>Air Quality</div>\n                        <div id=\"aqiValue\" class=\"text-2xl font-bold text-white\"></div>\n                        <div id=\"aqiStatus\" class=\"text-white/90 text-xs mt-1\"></div>\n                    </div>\n                </div>\n            </div>\n\n            <!-- Weekly Snow Totals -->\n            <div id=\"weeklySnowSection\" class=\"hidden weather-card rounded-2xl p-6 md:p-8 mb-6 border border-white/20 shadow-2xl\">\n                <h3 class=\"text-2xl font-bold text-white mb-4\">\n                    <i class=\"fas fa-snowflake mr-2\"></i>Weekly Snow Totals\n                </h3>\n                <div id=\"weeklySnowContent\" class=\"space-y-2\">\n                    <!-- Snow totals will be inserted here -->\n                </div>\n            </div>\n\n            <!-- Hourly Forecast -->\n            <div class=\"weather-card rounded-2xl p-6 md:p-8 mb-6 border border-white/20 shadow-2xl\">\n                <h3 class=\"text-2xl font-bold text-white mb-4 cursor-pointer hover:text-gray-200 transition-colors\" id=\"hourlyHeader\">\n                    <i class=\"fas fa-clock mr-2\"></i>24-Hour Forecast <i class=\"fas fa-external-link-alt ml-2 text-sm\"></i>\n                </h3>\n                <div id=\"hourlyForecast\" class=\"overflow-x-auto\">\n                    <div class=\"flex gap-4 min-w-max pb-2\">\n                        <!-- Hourly items will be inserted here -->\n                    </div>\n                </div>\n            </div>\n\n            <!-- Daily Forecast -->\n            <div class=\"weather-card rounded-2xl p-6 md:p-8 mb-6 border border-white/20 shadow-2xl\">\n                <h3 class=\"text-2xl font-bold text-white mb-4 cursor-pointer hover:text-gray-200 transition-colors\" id=\"dailyHeader\">\n                    <i class=\"fas fa-calendar-alt mr-2\"></i>7-Day Forecast <i class=\"fas fa-external-link-alt ml-2 text-sm\"></i>\n                </h3>\n                <div id=\"dailyForecast\" class=\"space-y-3\">\n                    <!-- Daily items will be inserted here -->\n                </div>\n            </div>\n\n            <!-- Weather Radar -->\n            <div class=\"weather-card rounded-2xl p-6 md:p-8 border border-white/20 shadow-2xl\">\n                <h3 class=\"text-2xl font-bold text-white mb-4\">\n                    <i class=\"fas fa-radar mr-2\"></i>Weather Radar\n                </h3>\n                <div id=\"radarContainer\" class=\"relative\">\n                    <!-- Leaflet map for wind layer -->\n                    <div id=\"radarMap\" style=\"height: 0; width: 100%; padding-bottom: 100%; border-radius: 0.5rem; overflow: hidden; position: relative; display: none;\">\n                        <!-- Legend - Top Right -->\n                        <div id=\"radarLegend\" class=\"absolute top-4 right-4 z-[1000]\"></div>\n                        <!-- Current Frame Time Display - Top Left -->\n                        <div id=\"radarTimeDisplay\" class=\"absolute top-4 left-4 z-[1000] bg-white/20 backdrop-blur-sm rounded-lg text-white px-3 py-2 border border-white/30 text-xs whitespace-nowrap hidden\">\n                            <i class=\"fas fa-clock mr-1\"></i><span id=\"radarTimeText\">--:-- --</span>\n                        </div>\n                        <!-- Navigation Controls - Bottom Left Corner of Map, All in a Row -->\n                        <div class=\"absolute bottom-4 left-4 z-[1000] flex items-center gap-2\">\n                        <!-- Zoom Controls -->\n                        <button id=\"radarZoomIn\" class=\"bg-white/20 hover:bg-white/30 backdrop-blur-sm rounded-lg text-white p-2 border border-white/30 transition-all\" title=\"Zoom In\">\n                            <i class=\"fas fa-plus\"></i>\n                        </button>\n                        <button id=\"radarZoomOut\" class=\"bg-white/20 hover:bg-white/30 backdrop-blur-sm rounded-lg text-white p-2 border border-white/30 transition-all\" title=\"Zoom Out\">\n                            <i class=\"fas fa-minus\"></i>\n                        </button>\n                        <!-- Divider -->\n                        <div class=\"w-px h-6 bg-white/30\"></div>\n                        <!-- Pan Controls -->\n                        <button id=\"radarMoveUp\" class=\"bg-white/20 hover:bg-white/30 backdrop-blur-sm rounded-lg text-white p-2 border border-white/30 transition-all\" title=\"Move Up\">\n                            <i class=\"fas fa-arrow-up\"></i>\n                        </button>\n                        <button id=\"radarMoveDown\" class=\"bg-white/20 hover:bg-white/30 backdrop-blur-sm rounded-lg text-white p-2 border border-white/30 transition-all\" title=\"Move Down\">\n                            <i class=\"fas fa-arrow-down\"></i>\n                        </button>\n                        <button id=\"radarMoveLeft\" class=\"bg-white/20 hover:bg-white/30 backdrop-blur-sm rounded-lg text-white p-2 border border-white/30 transition-all\" title=\"Move Left\">\n                            <i class=\"fas fa-arrow-left\"></i>\n                        </button>\n                        <button id=\"radarMoveRight\" class=\"bg-white/20 hover:bg-white/30 backdrop-blur-sm rounded-lg text-white p-2 border border-white/30 transition-all\" title=\"Move Right\">\n                            <i class=\"fas fa-arrow-right\"></i>\n                        </button>\n                        <!-- Divider -->\n                        <div class=\"w-px h-6 bg-white/30\"></div>\n                        <!-- Play/Pause Animation Button -->\n                        <button id=\"radarPlayPause\" class=\"bg-white/20 hover:bg-white/30 backdrop-blur-sm rounded-lg text-white p-2 border border-white/30 transition-all\" title=\"Play Animation\">\n                            <i class=\"fas fa-play\"></i>\n                        </button>\n                        </div>\n                    </div>\n                    <div class=\"mt-4 space-y-3\">\n                        <!-- Layer Selection -->\n                        <div class=\"flex items-center justify-center gap-2\">\n                            <button id=\"radarLayerPrecipitation\" class=\"radar-layer-btn px-4 py-2 bg-blue-500/30 hover:bg-blue-500/40 rounded-lg transition-all text-white font-semibold border-2 border-blue-400\">\n                                <i class=\"fas fa-cloud-rain mr-2\"></i>Precipitation\n                            </button>\n                            <button id=\"radarLayerWind\" class=\"radar-layer-btn px-4 py-2 bg-white/20 hover:bg-white/30 rounded-lg transition-all text-white font-semibold border-2 border-transparent\">\n                                <i class=\"fas fa-wind mr-2\"></i>Wind\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Hourly Forecast Modal -->\n    <div id=\"hourlyModal\" class=\"modal\">\n        <div class=\"modal-content p-6 md:p-8\">\n            <div class=\"flex justify-between items-center mb-6\">\n                <h2 class=\"text-3xl font-bold text-white\">\n                    <i class=\"fas fa-clock mr-2\"></i>24-Hour Detailed Forecast\n                </h2>\n                <button id=\"closeHourlyModal\" class=\"text-white hover:text-gray-300 text-2xl\">\n                    <i class=\"fas fa-times\"></i>\n                </button>\n            </div>\n            <div class=\"space-y-6\">\n                <div class=\"bg-white/10 rounded-lg p-4\">\n                    <canvas id=\"hourlyTempChart\" style=\"height: 250px;\"></canvas>\n                </div>\n                <div class=\"bg-white/10 rounded-lg p-4\">\n                    <canvas id=\"hourlyPrecipChart\" style=\"height: 250px;\"></canvas>\n                </div>\n                <div class=\"bg-white/10 rounded-lg p-4\">\n                    <canvas id=\"hourlyWindChart\" style=\"height: 250px;\"></canvas>\n                </div>\n                <div class=\"bg-white/10 rounded-lg p-4\">\n                    <canvas id=\"hourlyHumidityChart\" style=\"height: 250px;\"></canvas>\n                </div>\n                <div class=\"bg-white/10 rounded-lg p-4\">\n                    <canvas id=\"hourlySnowChart\" style=\"height: 250px;\"></canvas>\n                </div>\n                <div id=\"hourlyDetails\" class=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                    <!-- Detailed hourly items will be inserted here -->\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Daily Forecast Modal -->\n    <div id=\"dailyModal\" class=\"modal\">\n        <div class=\"modal-content p-6 md:p-8\">\n            <div class=\"flex justify-between items-center mb-6\">\n                <h2 class=\"text-3xl font-bold text-white\">\n                    <i class=\"fas fa-calendar-alt mr-2\"></i>7-Day Detailed Forecast\n                </h2>\n                <button id=\"closeDailyModal\" class=\"text-white hover:text-gray-300 text-2xl\">\n                    <i class=\"fas fa-times\"></i>\n                </button>\n            </div>\n            <div class=\"space-y-6\">\n                <div class=\"bg-white/10 rounded-lg p-4\">\n                    <canvas id=\"dailyTempChart\" style=\"height: 250px;\"></canvas>\n                </div>\n                <div class=\"bg-white/10 rounded-lg p-4\">\n                    <canvas id=\"dailyPrecipChart\" style=\"height: 250px;\"></canvas>\n                </div>\n                <div class=\"bg-white/10 rounded-lg p-4\">\n                    <canvas id=\"dailyWindChart\" style=\"height: 250px;\"></canvas>\n                </div>\n                <div class=\"bg-white/10 rounded-lg p-4\">\n                    <canvas id=\"dailySnowChart\" style=\"height: 250px;\"></canvas>\n                </div>\n                <div id=\"dailyDetails\" class=\"space-y-3\">\n                    <!-- Detailed daily items will be inserted here -->\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"/app.js\"></script>\n</body>\n</html>\n\n";
const JS_CONTENT = "let currentLat = null;\nlet currentLon = null;\nlet currentLocationName = null;\nlet currentWeatherData = null; // Store full weather data for modals\nlet favorites = []; // Array of favorite locations\nlet hourlyChart = null;\nlet dailyChart = null;\nlet radarMap = null;\nlet radarLayer = null;\nlet radarFrames = []; // Frame structure: { time: unixTimestamp, isoTime: \"ISO8601\", intensityPath: \"precipitationIntensity\", typePath: \"precipitationType\", precipitationTypes: Set }\nlet currentRadarFrame = 0;\nlet currentRadarLayerType = 'precipitation'; // 'precipitation' or 'wind'\nlet windMarkers = [];\nlet windDataCache = null;\nlet windCanvasLayer = null;\nlet windGridData = null;\nlet mapMoveDebounceTimer = null; // Debounce timer for map movement\nlet radarAnimationInterval = null; // Animation interval for radar playback\nlet isRadarAnimating = false; // Whether radar animation is playing\nlet radarAnimationFrame = null; // requestAnimationFrame ID for smooth animation\n\n// Favorites management using IndexedDB (more persistent than localStorage)\nlet favoritesDB = null;\n\n// Initialize IndexedDB\nfunction initFavoritesDB() {\n    return new Promise((resolve, reject) => {\n        const request = indexedDB.open('WeatherAppDB', 1);\n        \n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => {\n            favoritesDB = request.result;\n            resolve(favoritesDB);\n        };\n        \n        request.onupgradeneeded = (event) => {\n            const db = event.target.result;\n            if (!db.objectStoreNames.contains('favorites')) {\n                db.createObjectStore('favorites', { keyPath: 'id', autoIncrement: true });\n            }\n        };\n    });\n}\n\n// Load favorites from IndexedDB\nasync function loadFavorites() {\n    try {\n        if (!favoritesDB) {\n            await initFavoritesDB();\n        }\n        \n        const transaction = favoritesDB.transaction(['favorites'], 'readonly');\n        const store = transaction.objectStore('favorites');\n        const request = store.getAll();\n        \n        request.onsuccess = () => {\n            const dbFavorites = request.result;\n            \n            // If IndexedDB is empty, try to migrate from localStorage\n            if (dbFavorites.length === 0) {\n                const saved = localStorage.getItem('weatherFavorites');\n                if (saved) {\n                    try {\n                        const localFavorites = JSON.parse(saved);\n                        if (localFavorites && localFavorites.length > 0) {\n                            // Migrate from localStorage to IndexedDB\n                            favorites = localFavorites;\n                            saveFavorites(); // This will save to IndexedDB\n                            return;\n                        }\n                    } catch (e) {\n                        console.error('Error parsing localStorage favorites:', e);\n                    }\n                }\n            }\n            \n            // Extract favorites from IndexedDB (remove id field)\n            favorites = dbFavorites.map(fav => ({\n                name: fav.name,\n                lat: fav.lat,\n                lon: fav.lon\n            }));\n            renderFavorites();\n        };\n        \n        request.onerror = () => {\n            console.error('Error loading favorites from IndexedDB');\n            // Fallback to localStorage\n            const saved = localStorage.getItem('weatherFavorites');\n            if (saved) {\n                try {\n                    favorites = JSON.parse(saved);\n                } catch (e) {\n                    favorites = [];\n                }\n            }\n            renderFavorites();\n        };\n    } catch (error) {\n        console.error('Error initializing favorites DB:', error);\n        // Fallback to localStorage if IndexedDB fails\n        const saved = localStorage.getItem('weatherFavorites');\n        if (saved) {\n            try {\n                favorites = JSON.parse(saved);\n            } catch (e) {\n                favorites = [];\n            }\n        }\n        renderFavorites();\n    }\n}\n\n// Save favorites to IndexedDB\nasync function saveFavorites() {\n    try {\n        if (!favoritesDB) {\n            await initFavoritesDB();\n        }\n        \n        const transaction = favoritesDB.transaction(['favorites'], 'readwrite');\n        const store = transaction.objectStore('favorites');\n        \n        // Clear existing favorites\n        await new Promise((resolve, reject) => {\n            const clearRequest = store.clear();\n            clearRequest.onsuccess = () => resolve();\n            clearRequest.onerror = () => reject(clearRequest.error);\n        });\n        \n        // Add all current favorites\n        const promises = favorites.map(fav => {\n            return new Promise((resolve, reject) => {\n                const addRequest = store.add(fav);\n                addRequest.onsuccess = () => resolve();\n                addRequest.onerror = () => reject(addRequest.error);\n            });\n        });\n        \n        await Promise.all(promises);\n        \n        // Also save to localStorage as backup\n        localStorage.setItem('weatherFavorites', JSON.stringify(favorites));\n        \n        renderFavorites();\n    } catch (error) {\n        console.error('Error saving favorites to IndexedDB:', error);\n        // Fallback to localStorage\n        try {\n            localStorage.setItem('weatherFavorites', JSON.stringify(favorites));\n        } catch (e) {\n            console.error('Error saving to localStorage:', e);\n        }\n        renderFavorites();\n    }\n}\n\nfunction addFavorite() {\n    if (!currentLat || !currentLon || !currentLocationName) {\n        alert('Please search for a location first or use your current location.');\n        return;\n    }\n    \n    // Check if already in favorites\n    const exists = favorites.some(fav => \n        Math.abs(fav.lat - currentLat) < 0.001 && \n        Math.abs(fav.lon - currentLon) < 0.001\n    );\n    \n    if (exists) {\n        alert('This location is already in your favorites.');\n        return;\n    }\n    \n    favorites.push({\n        name: currentLocationName,\n        lat: currentLat,\n        lon: currentLon\n    });\n    \n    saveFavorites();\n}\n\nfunction removeFavorite(index) {\n    favorites.splice(index, 1);\n    saveFavorites();\n}\n\nfunction switchToFavorite(lat, lon, name) {\n    currentLocationName = name;\n    fetchWeather(lat, lon);\n    document.getElementById('favoritesDropdown').classList.add('hidden');\n}\n\nfunction renderFavorites() {\n    const favoritesList = document.getElementById('favoritesList');\n    const noFavorites = document.getElementById('noFavorites');\n    \n    favoritesList.innerHTML = '';\n    \n    if (favorites.length === 0) {\n        noFavorites.classList.remove('hidden');\n        favoritesList.classList.add('hidden');\n    } else {\n        noFavorites.classList.add('hidden');\n        favoritesList.classList.remove('hidden');\n        \n        favorites.forEach((fav, index) => {\n            const favItem = document.createElement('div');\n            favItem.className = 'flex items-center justify-between p-3 hover:bg-white/10 rounded-lg mb-1';\n            \n            const nameDiv = document.createElement('div');\n            nameDiv.className = 'flex-1 cursor-pointer';\n            nameDiv.innerHTML = `\n                <div class=\"text-white font-semibold\">${fav.name}</div>\n                <div class=\"text-white/60 text-xs\">${fav.lat.toFixed(4)}, ${fav.lon.toFixed(4)}</div>\n            `;\n            nameDiv.addEventListener('click', () => switchToFavorite(fav.lat, fav.lon, fav.name));\n            \n            const deleteBtn = document.createElement('button');\n            deleteBtn.className = 'text-red-400 hover:text-red-300 ml-2 p-1';\n            deleteBtn.innerHTML = '<i class=\"fas fa-trash\"></i>';\n            deleteBtn.addEventListener('click', (e) => {\n                e.stopPropagation();\n                removeFavorite(index);\n            });\n            \n            favItem.appendChild(nameDiv);\n            favItem.appendChild(deleteBtn);\n            favoritesList.appendChild(favItem);\n        });\n    }\n}\n\n// Initialize with user's location or default\nwindow.addEventListener('DOMContentLoaded', () => {\n    loadFavorites();\n    \n    // Favorites button click handler\n    document.getElementById('favoritesBtn').addEventListener('click', (e) => {\n        e.stopPropagation();\n        const dropdown = document.getElementById('favoritesDropdown');\n        dropdown.classList.toggle('hidden');\n    });\n    \n    // Add favorite button\n    document.getElementById('addFavoriteBtn').addEventListener('click', (e) => {\n        e.stopPropagation();\n        addFavorite();\n    });\n    \n    // Close dropdown when clicking outside\n    document.addEventListener('click', (e) => {\n        const dropdown = document.getElementById('favoritesDropdown');\n        const btn = document.getElementById('favoritesBtn');\n        if (!dropdown.contains(e.target) && !btn.contains(e.target)) {\n            dropdown.classList.add('hidden');\n        }\n    });\n    \n    if (navigator.geolocation) {\n        navigator.geolocation.getCurrentPosition(\n            (position) => {\n                currentLat = position.coords.latitude;\n                currentLon = position.coords.longitude;\n                fetchWeather(currentLat, currentLon);\n            },\n            () => {\n                // Default to London if geolocation fails\n                fetchWeather(51.5074, -0.1278);\n            }\n        );\n    } else {\n        fetchWeather(51.5074, -0.1278);\n    }\n});\n\n// Search functionality\ndocument.getElementById('searchBtn').addEventListener('click', handleSearch);\ndocument.getElementById('locationInput').addEventListener('keypress', (e) => {\n    if (e.key === 'Enter') handleSearch();\n});\ndocument.getElementById('locationBtn').addEventListener('click', () => {\n    if (navigator.geolocation) {\n        navigator.geolocation.getCurrentPosition(\n            (position) => {\n                currentLat = position.coords.latitude;\n                currentLon = position.coords.longitude;\n                fetchWeather(currentLat, currentLon);\n            },\n            () => showError('Unable to get your location. Please search for a city.')\n        );\n    } else {\n        showError('Geolocation is not supported by your browser.');\n    }\n});\n\n// State abbreviation to full name mapping (US states)\nconst STATE_ABBREVIATIONS = {\n    'AL': 'Alabama', 'AK': 'Alaska', 'AZ': 'Arizona', 'AR': 'Arkansas', 'CA': 'California',\n    'CO': 'Colorado', 'CT': 'Connecticut', 'DE': 'Delaware', 'FL': 'Florida', 'GA': 'Georgia',\n    'HI': 'Hawaii', 'ID': 'Idaho', 'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa',\n    'KS': 'Kansas', 'KY': 'Kentucky', 'LA': 'Louisiana', 'ME': 'Maine', 'MD': 'Maryland',\n    'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi', 'MO': 'Missouri',\n    'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada', 'NH': 'New Hampshire', 'NJ': 'New Jersey',\n    'NM': 'New Mexico', 'NY': 'New York', 'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio',\n    'OK': 'Oklahoma', 'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina',\n    'SD': 'South Dakota', 'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah', 'VT': 'Vermont',\n    'VA': 'Virginia', 'WA': 'Washington', 'WV': 'West Virginia', 'WI': 'Wisconsin', 'WY': 'Wyoming',\n    'DC': 'District of Columbia'\n};\n\n// Reverse mapping (full name to abbreviation)\nconst STATE_NAMES_TO_ABBR = {};\nObject.keys(STATE_ABBREVIATIONS).forEach(abbr => {\n    STATE_NAMES_TO_ABBR[STATE_ABBREVIATIONS[abbr].toLowerCase()] = abbr;\n});\n\nfunction normalizeState(stateInput) {\n    if (!stateInput) return null;\n    const state = stateInput.trim();\n    // Check if it's an abbreviation\n    if (state.length <= 2) {\n        return STATE_ABBREVIATIONS[state.toUpperCase()] || state;\n    }\n    // Check if it's a full name\n    const lowerState = state.toLowerCase();\n    if (STATE_NAMES_TO_ABBR[lowerState]) {\n        return STATE_ABBREVIATIONS[STATE_NAMES_TO_ABBR[lowerState]];\n    }\n    // Return as-is if not found\n    return state;\n}\n\nfunction matchesState(result, searchState) {\n    if (!searchState) return true;\n    const resultAdmin1 = (result.admin1 || '').toLowerCase();\n    const normalizedSearch = normalizeState(searchState).toLowerCase();\n    return resultAdmin1 === normalizedSearch || \n           resultAdmin1.includes(normalizedSearch) || \n           normalizedSearch.includes(resultAdmin1);\n}\n\nasync function handleSearch() {\n    const query = document.getElementById('locationInput').value.trim();\n    if (!query) return;\n\n    try {\n        // Parse \"City, State\" or \"City, State, Country\" format\n        const parts = query.split(',').map(p => p.trim());\n        const city = parts[0];\n        const state = parts.length > 1 ? parts[1] : null;\n        const country = parts.length > 2 ? parts[2] : null;\n        \n        // Build search query - use city name, optionally add country filter\n        let searchUrl = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}`;\n        if (country) {\n            searchUrl += `&country=${encodeURIComponent(country)}`;\n        }\n        // Get more results to filter through (up to 10)\n        searchUrl += `&count=10`;\n        \n        const response = await fetch(searchUrl);\n        const data = await response.json();\n        \n        if (data.results && data.results.length > 0) {\n            let result = data.results[0];\n            \n            // If state was provided, try to find a match\n            if (state) {\n                const stateMatch = data.results.find(r => matchesState(r, state));\n                if (stateMatch) {\n                    result = stateMatch;\n                } else {\n                    // If no exact match, show all results and let user know\n                    console.log('State not found, using first result:', result);\n                }\n            }\n            \n            currentLat = result.latitude;\n            currentLon = result.longitude;\n            \n            // Store the location name for display - try multiple fields\n            const name = result.name || result.admin1 || result.admin2 || '';\n            const resultCountry = result.country || '';\n            const admin1 = result.admin1 || '';\n            \n            // Check if it's US (handle various formats)\n            const isUS = resultCountry && (\n                resultCountry.includes('United States') || \n                resultCountry === 'US' || \n                resultCountry === 'USA'\n            );\n            \n            if (name && resultCountry) {\n                // For US locations, prefer \"City, State\" format\n                if (isUS && admin1) {\n                    currentLocationName = `${name}, ${admin1}`;\n                } else if (!isUS) {\n                    // For non-US locations, show \"City, Country\"\n                    currentLocationName = `${name}, ${resultCountry}`;\n                } else {\n                    currentLocationName = name;\n                }\n            } else if (name) {\n                currentLocationName = name;\n            } else if (admin1) {\n                currentLocationName = admin1;\n            } else {\n                currentLocationName = null; // Will trigger reverse geocoding\n            }\n            \n            fetchWeather(currentLat, currentLon);\n        } else {\n            showError('Location not found. Please try another search.');\n        }\n    } catch (error) {\n        showError('Error searching for location. Please try again.');\n        console.error(error);\n    }\n}\n\nasync function fetchWeather(lat, lon) {\n    showLoading();\n    hideError();\n    hideContent();\n\n    try {\n        // Make direct request to Open-Meteo from browser (uses user's IP, not shared Cloudflare IP)\n        const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,wind_speed_10m,uv_index,weather_code&hourly=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m,precipitation_probability,precipitation,snowfall&daily=weather_code,temperature_2m_max,temperature_2m_min,precipitation_sum,wind_speed_10m_max,precipitation_probability_max,snowfall_sum,sunrise,sunset&temperature_unit=fahrenheit&windspeed_unit=mph&precipitation_unit=inch&timezone=auto`);\n\n        // Check for rate limiting before parsing JSON\n        if (weatherResponse.status === 429) {\n            const errorData = await weatherResponse.json().catch(() => ({ error: true, reason: 'Rate limit exceeded' }));\n            showError(errorData.reason || 'Rate limit exceeded. Please wait a moment and try again.');\n            return;\n        }\n\n        if (!weatherResponse.ok) {\n            const errorData = await weatherResponse.json().catch(() => ({ error: true, reason: 'Failed to fetch weather data' }));\n            showError(errorData.reason || `Failed to fetch weather data (${weatherResponse.status})`);\n            return;\n        }\n\n        const weatherData = await weatherResponse.json();\n\n        if (weatherData.error) {\n            showError(weatherData.reason || 'Failed to fetch weather data');\n            return;\n        }\n\n        // If we don't have a stored location name, try to get it via reverse geocoding\n        if (!currentLocationName) {\n            try {\n                // Make direct request to BigDataCloud from browser (uses user's IP, not shared Cloudflare IP)\n                const controller = new AbortController();\n                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout\n                \n                const reverseGeoResponse = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}&localityLanguage=en`, {\n                    signal: controller.signal\n                });\n                \n                clearTimeout(timeoutId);\n                \n                if (!reverseGeoResponse.ok) {\n                    throw new Error(`HTTP ${reverseGeoResponse.status}`);\n                }\n                \n                const data = await reverseGeoResponse.json();\n                \n                // BigDataCloud returns data directly - transform to match expected format\n                if (data) {\n                    // Try to get city name, fallback to town, village, or municipality\n                    const cityName = data.city || data.locality || data.town || data.village || data.municipality || data.county;\n                    const stateName = data.principalSubdivision;\n                    const countryName = data.countryName;\n                    \n                    // Check if it's US (handle various formats like \"United States\", \"United States of America\", etc.)\n                    const isUS = countryName && (\n                        countryName.includes('United States') || \n                        countryName === 'US' || \n                        countryName === 'USA'\n                    );\n                    \n                    if (cityName) {\n                        if (stateName && isUS) {\n                            // For US locations, show \"City, State\"\n                            currentLocationName = `${cityName}, ${stateName}`;\n                        } else if (countryName && !isUS) {\n                            // For non-US locations, show \"City, Country\"\n                            currentLocationName = `${cityName}, ${countryName}`;\n                        } else {\n                            currentLocationName = cityName;\n                        }\n                    } else if (stateName && isUS) {\n                        currentLocationName = stateName;\n                    } else if (countryName && !isUS) {\n                        currentLocationName = countryName;\n                    }\n                }\n            } catch (error) {\n                // Log error for debugging but don't break the app\n                console.error('Reverse geocoding failed:', error.message);\n            }\n        }\n\n        currentWeatherData = weatherData; // Store for modals\n        displayWeather(weatherData);\n        \n        // Update legend if radar is already initialized (to reflect rain vs snow)\n        if (currentRadarLayerType === 'precipitation') {\n            initializeLegend();\n        }\n        \n        // Initialize radar map\n        initializeRadar(lat, lon);\n        \n        // Fetch weather alerts (for US locations)\n        fetchWeatherAlerts(lat, lon);\n        \n        // Fetch air quality data\n        fetchAirQuality(lat, lon);\n    } catch (error) {\n        showError('Failed to fetch weather data. Please try again.');\n        console.error(error);\n    } finally {\n        hideLoading();\n    }\n}\n\nfunction displayWeather(data) {\n    // Use stored location name if available (from search or reverse geocoding)\n    let location = currentLocationName;\n    \n    // If we still don't have a location name, show coordinates as last resort\n    if (!location) {\n        location = `${data.latitude.toFixed(2)}, ${data.longitude.toFixed(2)}`;\n    }\n\n    // Current weather\n    document.getElementById('currentLocation').textContent = location;\n    document.getElementById('currentDate').textContent = new Date().toLocaleDateString('en-US', { \n        weekday: 'long', \n        year: 'numeric', \n        month: 'long', \n        day: 'numeric' \n    });\n    document.getElementById('currentTemp').textContent = `${Math.round(data.current.temperature_2m)}${data.current_units.temperature_2m}`;\n    document.getElementById('currentCondition').textContent = getWeatherDescription(data.current.weather_code);\n    document.getElementById('feelsLike').textContent = `${Math.round(data.current.apparent_temperature)}${data.current_units.apparent_temperature}`;\n    document.getElementById('humidity').textContent = `${data.current.relative_humidity_2m}${data.current_units.relative_humidity_2m}`;\n    document.getElementById('windSpeed').textContent = `${data.current.wind_speed_10m} ${data.current_units.wind_speed_10m}`;\n    document.getElementById('uvIndex').textContent = data.current.uv_index;\n    \n    // Sunrise and sunset times (for today, index 0)\n    if (data.daily && data.daily.sunrise && data.daily.sunrise[0]) {\n        const sunriseTime = new Date(data.daily.sunrise[0]);\n        document.getElementById('sunrise').textContent = formatTime12Hour(sunriseTime);\n    }\n    if (data.daily && data.daily.sunset && data.daily.sunset[0]) {\n        const sunsetTime = new Date(data.daily.sunset[0]);\n        document.getElementById('sunset').textContent = formatTime12Hour(sunsetTime);\n    }\n\n    // Hourly forecast\n    const hourlyContainer = document.getElementById('hourlyForecast').querySelector('.flex');\n    hourlyContainer.innerHTML = '';\n    const now = new Date();\n    const currentHour = now.getHours();\n    \n    // Find the closest hour in the data\n    let startIndex = 0;\n    for (let i = 0; i < data.hourly.time.length; i++) {\n        const hourTime = new Date(data.hourly.time[i]);\n        if (hourTime.getHours() >= currentHour) {\n            startIndex = i;\n            break;\n        }\n    }\n    \n    for (let i = 0; i < 24 && (startIndex + i) < data.hourly.time.length; i++) {\n        const hourIndex = startIndex + i;\n        const hour = new Date(data.hourly.time[hourIndex]);\n        const hourItem = document.createElement('div');\n        hourItem.className = 'flex flex-col items-center bg-white/10 rounded-lg p-3 backdrop-blur-sm min-w-[80px] clickable';\n        hourItem.innerHTML = `\n            <div class=\"text-white/70 text-sm mb-1\">${formatTime12Hour(hour)}</div>\n            <div class=\"text-2xl mb-2\">${getWeatherIcon(data.hourly.weather_code[hourIndex])}</div>\n            <div class=\"text-white font-bold text-lg\">${Math.round(data.hourly.temperature_2m[hourIndex])}${data.hourly_units.temperature_2m}</div>\n            <div class=\"text-white/60 text-xs mt-1\">${data.hourly.wind_speed_10m[hourIndex]} ${data.hourly_units.wind_speed_10m}</div>\n        `;\n        hourItem.addEventListener('click', () => openHourlyModal(data));\n        hourlyContainer.appendChild(hourItem);\n    }\n\n    // Daily forecast\n    const dailyContainer = document.getElementById('dailyForecast');\n    dailyContainer.innerHTML = '';\n    \n    for (let i = 0; i < Math.min(7, data.daily.time.length); i++) {\n        const day = parseDateString(data.daily.time[i]);\n        const dayItem = document.createElement('div');\n        dayItem.className = 'flex items-center justify-between bg-white/10 rounded-lg p-4 backdrop-blur-sm clickable';\n        dayItem.innerHTML = `\n            <div class=\"flex items-center gap-4\">\n                <div class=\"text-3xl\">${getWeatherIcon(data.daily.weather_code[i])}</div>\n                <div>\n                    <div class=\"text-white font-semibold text-lg\">${day.toLocaleDateString('en-US', { weekday: 'long' })}</div>\n                    <div class=\"text-white/70 text-sm\">${day.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</div>\n                </div>\n            </div>\n            <div class=\"flex items-center gap-6\">\n                <div class=\"text-right\">\n                    <div class=\"text-white font-bold text-xl\">${Math.round(data.daily.temperature_2m_max[i])}${data.daily_units.temperature_2m_max}</div>\n                    <div class=\"text-white/70 text-sm\">${Math.round(data.daily.temperature_2m_min[i])}${data.daily_units.temperature_2m_min}</div>\n                </div>\n                <div class=\"text-white/70 text-sm text-right min-w-[100px]\">\n                    ${data.daily.snowfall_sum && data.daily.snowfall_sum[i] > 0 ? '' : `<div><i class=\"fas fa-tint mr-1\"></i>${data.daily.precipitation_sum[i] || 0} ${data.daily_units.precipitation_sum}</div>`}\n                    ${data.daily.snowfall_sum && data.daily.snowfall_sum[i] > 0 ? `<div><i class=\"fas fa-snowflake mr-1\"></i>${data.daily.snowfall_sum[i]} ${data.daily_units.snowfall_sum || 'in'}</div>` : ''}\n                    <div><i class=\"fas fa-wind mr-1\"></i>${data.daily.wind_speed_10m_max[i]} ${data.daily_units.wind_speed_10m_max}</div>\n                </div>\n            </div>\n        `;\n        dayItem.addEventListener('click', () => openDailyModal(data));\n        dailyContainer.appendChild(dayItem);\n    }\n\n    // Display weekly snow totals if there's snow in the forecast\n    displayWeeklySnowTotals(data);\n\n    showContent();\n    \n    // Add click handlers to section headers\n    if (currentWeatherData) {\n        document.getElementById('hourlyHeader').addEventListener('click', () => openHourlyModal(currentWeatherData));\n        document.getElementById('dailyHeader').addEventListener('click', () => openDailyModal(currentWeatherData));\n    }\n}\n\nfunction displayWeeklySnowTotals(data) {\n    const snowSection = document.getElementById('weeklySnowSection');\n    const snowContent = document.getElementById('weeklySnowContent');\n    snowContent.innerHTML = '';\n    \n    // Check if there's any snow in the forecast\n    if (!data.daily.snowfall_sum) {\n        snowSection.classList.add('hidden');\n        return;\n    }\n    \n    // Collect all days with snow\n    const snowDays = [];\n    for (let i = 0; i < Math.min(7, data.daily.time.length); i++) {\n        const snowfall = data.daily.snowfall_sum[i] || 0;\n        if (snowfall > 0) {\n            const day = parseDateString(data.daily.time[i]);\n            const dayName = day.toLocaleDateString('en-US', { weekday: 'long' });\n            const dateStr = day.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });\n            // Round to nearest 0.1 inch\n            const roundedSnow = Math.round(snowfall * 10) / 10;\n            snowDays.push({\n                dayName,\n                dateStr,\n                snowfall: roundedSnow,\n                index: i\n            });\n        }\n    }\n    \n    if (snowDays.length === 0) {\n        snowSection.classList.add('hidden');\n        return;\n    }\n    \n    // Group consecutive days\n    const snowPeriods = [];\n    let currentPeriod = null;\n    \n    for (let i = 0; i < snowDays.length; i++) {\n        const snowDay = snowDays[i];\n        \n        if (!currentPeriod) {\n            // Start new period\n            currentPeriod = {\n                days: [snowDay],\n                totalSnow: snowDay.snowfall\n            };\n        } else {\n            // Check if consecutive (within 1 day index difference)\n            const lastDayIndex = currentPeriod.days[currentPeriod.days.length - 1].index;\n            if (snowDay.index === lastDayIndex + 1) {\n                // Consecutive day - add to current period\n                currentPeriod.days.push(snowDay);\n                currentPeriod.totalSnow += snowDay.snowfall;\n            } else {\n                // Not consecutive - save current period and start new one\n                snowPeriods.push(currentPeriod);\n                currentPeriod = {\n                    days: [snowDay],\n                    totalSnow: snowDay.snowfall\n                };\n            }\n        }\n    }\n    \n    // Add the last period\n    if (currentPeriod) {\n        snowPeriods.push(currentPeriod);\n    }\n    \n    // Display snow periods\n    snowSection.classList.remove('hidden');\n    \n    snowPeriods.forEach(period => {\n        const periodItem = document.createElement('div');\n        periodItem.className = 'bg-white/10 rounded-lg p-4 backdrop-blur-sm';\n        \n        // Round total to nearest 0.1\n        const totalSnowRounded = Math.round(period.totalSnow * 10) / 10;\n        \n        // Determine unit (inch vs inches)\n        const unit = totalSnowRounded === 1.0 ? 'inch' : 'inches';\n        \n        let periodText;\n        if (period.days.length === 1) {\n            // Single day\n            const day = period.days[0];\n            const dayUnit = day.snowfall === 1.0 ? 'inch' : 'inches';\n            periodText = `Snowfall on ${day.dayName} (${day.dateStr}) is ${totalSnowRounded.toFixed(1)} ${unit}`;\n            \n            periodItem.innerHTML = `\n                <div class=\"text-white font-semibold\">${periodText}</div>\n            `;\n        } else {\n            // Multiple days - show range\n            const firstDay = period.days[0];\n            const lastDay = period.days[period.days.length - 1];\n            periodText = `Snowfall between ${firstDay.dayName} (${firstDay.dateStr}) and ${lastDay.dayName} (${lastDay.dateStr}) is ${totalSnowRounded.toFixed(1)} ${unit}`;\n            \n            // Add breakdown of individual days\n            const dayBreakdown = period.days.map(day => {\n                const dayUnit = day.snowfall === 1.0 ? 'inch' : 'inches';\n                return `${day.dayName}: ${day.snowfall.toFixed(1)} ${dayUnit}`;\n            }).join('  ');\n            \n            periodItem.innerHTML = `\n                <div class=\"flex-1\">\n                    <div class=\"text-white font-semibold mb-1\">${periodText}</div>\n                    <div class=\"text-white/70 text-sm\">${dayBreakdown}</div>\n                </div>\n            `;\n        }\n        \n        snowContent.appendChild(periodItem);\n    });\n}\n\nfunction getWeatherIcon(code) {\n    // WMO Weather interpretation codes\n    const icons = {\n        0: '', 1: '', 2: '', 3: '',\n        45: '', 48: '',\n        51: '', 53: '', 55: '',\n        56: '', 57: '',\n        61: '', 63: '', 65: '',\n        66: '', 67: '',\n        71: '', 73: '', 75: '',\n        77: '',\n        80: '', 81: '', 82: '',\n        85: '', 86: '',\n        95: '', 96: '', 99: ''\n    };\n    return icons[code] || '';\n}\n\nfunction getWeatherDescription(code) {\n    const descriptions = {\n        0: 'Clear sky', 1: 'Mainly clear', 2: 'Partly cloudy', 3: 'Overcast',\n        45: 'Foggy', 48: 'Depositing rime fog',\n        51: 'Light drizzle', 53: 'Moderate drizzle', 55: 'Dense drizzle',\n        56: 'Light freezing drizzle', 57: 'Dense freezing drizzle',\n        61: 'Slight rain', 63: 'Moderate rain', 65: 'Heavy rain',\n        66: 'Light freezing rain', 67: 'Heavy freezing rain',\n        71: 'Slight snow', 73: 'Moderate snow', 75: 'Heavy snow',\n        77: 'Snow grains',\n        80: 'Slight rain showers', 81: 'Moderate rain showers', 82: 'Violent rain showers',\n        85: 'Slight snow showers', 86: 'Heavy snow showers',\n        95: 'Thunderstorm', 96: 'Thunderstorm with slight hail', 99: 'Thunderstorm with heavy hail'\n    };\n    return descriptions[code] || 'Unknown';\n}\n\nfunction formatTime12Hour(date) {\n    let hours = date.getHours();\n    const minutes = date.getMinutes();\n    const ampm = hours >= 12 ? 'PM' : 'AM';\n    hours = hours % 12;\n    hours = hours ? hours : 12; // the hour '0' should be '12'\n    const minutesStr = minutes < 10 ? '0' + minutes : minutes;\n    return `${hours}:${minutesStr} ${ampm}`;\n}\n\nfunction parseDateString(dateString) {\n    // Parse date string (format: \"YYYY-MM-DD\") as local date, not UTC\n    // This prevents timezone issues where UTC dates shift to previous day\n    const parts = dateString.split('-');\n    if (parts.length === 3) {\n        const year = parseInt(parts[0], 10);\n        const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed\n        const day = parseInt(parts[2], 10);\n        return new Date(year, month, day);\n    }\n    // Fallback to regular Date parsing if format is different\n    return new Date(dateString);\n}\n\nfunction showLoading() {\n    document.getElementById('loading').classList.remove('hidden');\n}\n\nfunction hideLoading() {\n    document.getElementById('loading').classList.add('hidden');\n}\n\nfunction showContent() {\n    document.getElementById('weatherContent').classList.remove('hidden');\n}\n\nfunction hideContent() {\n    document.getElementById('weatherContent').classList.add('hidden');\n}\n\nfunction showError(message) {\n    document.getElementById('errorMessage').classList.remove('hidden');\n    document.getElementById('errorText').textContent = message;\n}\n\nfunction hideError() {\n    document.getElementById('errorMessage').classList.add('hidden');\n}\n\n// Weather alerts functionality\nasync function fetchWeatherAlerts(lat, lon) {\n    // Only fetch alerts for US locations (rough check: lat 24-50, lon -125 to -66)\n    if (lat < 24 || lat > 50 || lon < -125 || lon > -66) {\n        return; // Not in US, skip alerts\n    }\n    \n    try {\n        // First, get the forecast zone for this point\n        const pointResponse = await fetch(`/api/nws-points/${lat.toFixed(4)},${lon.toFixed(4)}`);\n        \n        if (!pointResponse.ok) {\n            console.log('NWS points API not available:', pointResponse.status);\n            return; // Silently fail if not available\n        }\n        \n        const pointData = await pointResponse.json();\n        \n        // Check if the response has an error\n        if (pointData.error) {\n            console.log('NWS points API error:', pointData.reason);\n            return;\n        }\n        \n        const forecastZoneUrl = pointData.properties?.forecastZone;\n        \n        if (!forecastZoneUrl) {\n            console.log('No forecast zone URL found in NWS response');\n            return;\n        }\n        \n        // Extract zone ID from URL (e.g., \"https://api.weather.gov/zones/forecast/AZZ001\" -> \"AZZ001\")\n        const zoneId = forecastZoneUrl.split('/').pop();\n        \n        if (!zoneId) {\n            console.log('Could not extract zone ID from URL:', forecastZoneUrl);\n            return;\n        }\n        \n        // Fetch alerts for this zone\n        const alertsResponse = await fetch(`/api/alerts/active/zone/${zoneId}`);\n        \n        if (!alertsResponse.ok) {\n            console.log('NWS alerts API not available:', alertsResponse.status);\n            return;\n        }\n        \n        const alertsData = await alertsResponse.json();\n        \n        // Check if the response has an error\n        if (alertsData.error) {\n            console.log('NWS alerts API error:', alertsData.reason);\n            return;\n        }\n        \n        if (alertsData.features && alertsData.features.length > 0) {\n            // Filter to only show actual (active) alerts\n            const activeAlerts = alertsData.features.filter(alert => \n                alert.properties.status === 'Actual'\n            );\n            \n            if (activeAlerts.length > 0) {\n                displayAlerts(activeAlerts);\n            }\n        }\n    } catch (error) {\n        // Log error for debugging but don't break the app\n        console.error('Weather alerts error:', error.message);\n    }\n}\n\nfunction displayAlerts(alerts) {\n    const alertsContainer = document.getElementById('weatherAlerts');\n    alertsContainer.innerHTML = '';\n    alertsContainer.classList.remove('hidden');\n    \n    alerts.forEach((alert, index) => {\n        const props = alert.properties;\n        const severity = props.severity?.toLowerCase() || 'unknown';\n        const urgency = props.urgency?.toLowerCase() || 'unknown';\n        \n        // Determine alert color based on severity\n        let alertColor = 'bg-yellow-500/20 border-yellow-300/30';\n        if (severity === 'extreme' || severity === 'severe') {\n            alertColor = 'bg-red-500/20 border-red-300/30';\n        } else if (severity === 'moderate') {\n            alertColor = 'bg-orange-500/20 border-orange-300/30';\n        }\n        \n        const alertItem = document.createElement('div');\n        alertItem.className = `${alertColor} backdrop-blur-sm rounded-lg border shadow-lg mb-3`;\n        \n        const eventType = props.event || 'Weather Alert';\n        const headline = props.headline || '';\n        const description = props.description || '';\n        const effective = props.effective ? new Date(props.effective).toLocaleString('en-US') : '';\n        const expires = props.expires ? new Date(props.expires).toLocaleString('en-US') : '';\n        \n        // Create unique IDs for this alert\n        const alertId = `alert-${index}`;\n        const headerId = `alert-header-${index}`;\n        const contentId = `alert-content-${index}`;\n        const expandIconId = `alert-icon-${index}`;\n        \n        alertItem.innerHTML = `\n            <div class=\"cursor-pointer\" id=\"${headerId}\">\n                <div class=\"flex items-center justify-between p-4\">\n                    <div class=\"flex items-center gap-3 flex-1 min-w-0\">\n                        <i class=\"fas fa-exclamation-triangle text-2xl text-white flex-shrink-0\"></i>\n                        <div class=\"flex-1 min-w-0\">\n                            <div class=\"flex items-center gap-2 mb-1 flex-wrap\">\n                                <h3 class=\"text-xl font-bold text-white\">${eventType}</h3>\n                                ${props.severity ? `<span class=\"px-2 py-1 bg-white/20 rounded text-xs text-white font-semibold uppercase whitespace-nowrap\">${props.severity}</span>` : ''}\n                            </div>\n                            ${headline ? `<p class=\"text-white font-semibold text-sm\">${headline}</p>` : ''}\n                        </div>\n                    </div>\n                    <i id=\"${expandIconId}\" class=\"fas fa-chevron-down text-white transition-transform duration-200 flex-shrink-0 ml-2\"></i>\n                </div>\n            </div>\n            <div id=\"${contentId}\" class=\"hidden px-4 pb-4\">\n                <div class=\"border-t border-white/20 pt-4\">\n                    ${description ? `<p class=\"text-white/90 text-sm mb-3 whitespace-pre-line\">${description}</p>` : ''}\n                    ${(effective || expires) ? `\n                    <div class=\"flex flex-col gap-2 text-white/70 text-xs mt-4 pt-4 border-t border-white/10\">\n                        ${effective ? `<div><i class=\"fas fa-clock mr-1\"></i>Effective: ${effective}</div>` : ''}\n                        ${expires ? `<div><i class=\"fas fa-calendar-times mr-1\"></i>Expires: ${expires}</div>` : ''}\n                    </div>\n                    ` : ''}\n                </div>\n            </div>\n        `;\n        \n        // Add click handler for expand/collapse\n        const header = alertItem.querySelector(`#${headerId}`);\n        const content = alertItem.querySelector(`#${contentId}`);\n        const expandIcon = alertItem.querySelector(`#${expandIconId}`);\n        \n        header.addEventListener('click', () => {\n            const isExpanded = !content.classList.contains('hidden');\n            if (isExpanded) {\n                content.classList.add('hidden');\n                expandIcon.classList.remove('fa-chevron-up');\n                expandIcon.classList.add('fa-chevron-down');\n                expandIcon.style.transform = 'rotate(0deg)';\n            } else {\n                content.classList.remove('hidden');\n                expandIcon.classList.remove('fa-chevron-down');\n                expandIcon.classList.add('fa-chevron-up');\n                expandIcon.style.transform = 'rotate(180deg)';\n            }\n        });\n        \n        alertsContainer.appendChild(alertItem);\n    });\n}\n\n// Air Quality functionality\nasync function fetchAirQuality(lat, lon) {\n    try {\n        // Fetch air quality data from Open-Meteo Air Quality API\n        const aqiResponse = await fetch(`https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${lat}&longitude=${lon}&current=us_aqi,pm10,pm2_5,ozone,nitrogen_dioxide,sulphur_dioxide,carbon_monoxide`);\n        \n        if (!aqiResponse.ok) {\n            // Hide air quality section if API is unavailable\n            document.getElementById('airQualitySection').classList.add('hidden');\n            return;\n        }\n        \n        const aqiData = await aqiResponse.json();\n        \n        if (aqiData.error || !aqiData.current) {\n            document.getElementById('airQualitySection').classList.add('hidden');\n            return;\n        }\n        \n        displayAirQuality(aqiData.current);\n    } catch (error) {\n        console.error('Error fetching air quality:', error);\n        document.getElementById('airQualitySection').classList.add('hidden');\n    }\n}\n\nfunction displayAirQuality(data) {\n    const aqiSection = document.getElementById('airQualitySection');\n    const aqiValue = document.getElementById('aqiValue');\n    const aqiStatus = document.getElementById('aqiStatus');\n    \n    // Show the section\n    aqiSection.classList.remove('hidden');\n    \n    // Get US AQI (0-500 scale)\n    const usAqi = data.us_aqi || 0;\n    \n    // Determine AQI category and color\n    let category, color;\n    if (usAqi <= 50) {\n        category = 'Good';\n        color = 'text-green-400';\n    } else if (usAqi <= 100) {\n        category = 'Moderate';\n        color = 'text-yellow-400';\n    } else if (usAqi <= 150) {\n        category = 'Unhealthy for Sensitive Groups';\n        color = 'text-orange-400';\n    } else if (usAqi <= 200) {\n        category = 'Unhealthy';\n        color = 'text-red-400';\n    } else if (usAqi <= 300) {\n        category = 'Very Unhealthy';\n        color = 'text-purple-400';\n    } else {\n        category = 'Hazardous';\n        color = 'text-red-600';\n    }\n    \n    // Update display\n    aqiValue.textContent = usAqi;\n    aqiValue.className = `text-2xl font-bold ${color}`;\n    aqiStatus.textContent = category;\n    aqiStatus.className = `text-white/90 text-xs mt-1 ${color}`;\n}\n\n// Modal functionality\nfunction openHourlyModal(data) {\n    const modal = document.getElementById('hourlyModal');\n    modal.classList.add('active');\n    \n    // Destroy existing charts if they exist\n    if (hourlyChart) {\n        Object.values(hourlyChart).forEach(chart => {\n            if (chart) chart.destroy();\n        });\n    }\n    \n    // Prepare data\n    const now = new Date();\n    const currentHour = now.getHours();\n    let startIndex = 0;\n    for (let i = 0; i < data.hourly.time.length; i++) {\n        const hourTime = new Date(data.hourly.time[i]);\n        if (hourTime.getHours() >= currentHour) {\n            startIndex = i;\n            break;\n        }\n    }\n    \n    const hours = [];\n    const temps = [];\n    const precip = [];\n    const snow = [];\n    const wind = [];\n    const humidity = [];\n    const labels = [];\n    \n    for (let i = 0; i < 24 && (startIndex + i) < data.hourly.time.length; i++) {\n        const idx = startIndex + i;\n        const hour = new Date(data.hourly.time[idx]);\n        labels.push(formatTime12Hour(hour));\n        hours.push(hour);\n        temps.push(Math.round(data.hourly.temperature_2m[idx]));\n        precip.push(data.hourly.precipitation ? data.hourly.precipitation[idx] : 0);\n        snow.push(data.hourly.snowfall ? data.hourly.snowfall[idx] : 0);\n        wind.push(data.hourly.wind_speed_10m[idx]);\n        humidity.push(data.hourly.relative_humidity_2m[idx]);\n    }\n    \n    // Create charts\n    const chartConfig = {\n        type: 'line',\n        options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n                legend: {\n                    labels: { color: '#fff' }\n                }\n            },\n            scales: {\n                x: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } },\n                y: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } }\n            }\n        }\n    };\n    \n    // Check if there's any snow in the hourly forecast\n    const hasSnowHourly = snow.some(val => val > 0);\n    \n    hourlyChart = {\n        temp: new Chart(document.getElementById('hourlyTempChart'), {\n            ...chartConfig,\n            data: {\n                labels,\n                datasets: [{\n                    label: `Temperature (${data.hourly_units.temperature_2m})`,\n                    data: temps,\n                    borderColor: 'rgb(255, 99, 132)',\n                    backgroundColor: 'rgba(255, 99, 132, 0.2)',\n                    tension: 0.4\n                }]\n            }\n        }),\n        precip: new Chart(document.getElementById('hourlyPrecipChart'), {\n            ...chartConfig,\n            data: {\n                labels,\n                datasets: [{\n                    label: `Precipitation (${data.hourly_units.precipitation || 'in'})`,\n                    data: precip,\n                    borderColor: 'rgb(54, 162, 235)',\n                    backgroundColor: 'rgba(54, 162, 235, 0.2)',\n                    tension: 0.4,\n                    fill: true\n                }]\n            }\n        }),\n        wind: new Chart(document.getElementById('hourlyWindChart'), {\n            ...chartConfig,\n            data: {\n                labels,\n                datasets: [{\n                    label: `Wind Speed (${data.hourly_units.wind_speed_10m})`,\n                    data: wind,\n                    borderColor: 'rgb(255, 206, 86)',\n                    backgroundColor: 'rgba(255, 206, 86, 0.2)',\n                    tension: 0.4\n                }]\n            }\n        }),\n        humidity: new Chart(document.getElementById('hourlyHumidityChart'), {\n            ...chartConfig,\n            data: {\n                labels,\n                datasets: [{\n                    label: `Humidity (${data.hourly_units.relative_humidity_2m})`,\n                    data: humidity,\n                    borderColor: 'rgb(75, 192, 192)',\n                    backgroundColor: 'rgba(75, 192, 192, 0.2)',\n                    tension: 0.4\n                }]\n            }\n        }),\n        snow: new Chart(document.getElementById('hourlySnowChart'), {\n            ...chartConfig,\n            data: {\n                labels,\n                datasets: [{\n                    label: `Snowfall (${data.hourly_units.snowfall || 'in'})`,\n                    data: snow,\n                    borderColor: 'rgb(176, 196, 222)',\n                    backgroundColor: 'rgba(176, 196, 222, 0.2)',\n                    tension: 0.4,\n                    fill: true\n                }]\n            }\n        })\n    };\n    \n    // Hide/show precipitation and snow charts based on data\n    const hourlyPrecipChartContainer = document.getElementById('hourlyPrecipChart').parentElement;\n    const hourlySnowChartContainer = document.getElementById('hourlySnowChart').parentElement;\n    \n    if (hasSnowHourly) {\n        hourlyPrecipChartContainer.style.display = 'none';\n        hourlySnowChartContainer.style.display = 'block';\n    } else {\n        hourlyPrecipChartContainer.style.display = 'block';\n        hourlySnowChartContainer.style.display = 'none';\n    }\n    \n    // Populate detailed hourly items\n    const detailsContainer = document.getElementById('hourlyDetails');\n    detailsContainer.innerHTML = '';\n    for (let i = 0; i < hours.length; i++) {\n        const idx = startIndex + i;\n        const hour = hours[i];\n        const detailItem = document.createElement('div');\n        detailItem.className = 'bg-white/10 rounded-lg p-4 backdrop-blur-sm';\n        detailItem.innerHTML = `\n                <div class=\"flex items-center justify-between mb-2\">\n                <div class=\"text-white font-semibold\">${hour.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })} ${formatTime12Hour(hour)}</div>\n                <div class=\"text-2xl\">${getWeatherIcon(data.hourly.weather_code[idx])}</div>\n            </div>\n            <div class=\"grid grid-cols-2 gap-2 text-sm\">\n                <div><span class=\"text-white/70\">Temp:</span> <span class=\"text-white font-bold\">${Math.round(temps[i])}${data.hourly_units.temperature_2m}</span></div>\n                <div><span class=\"text-white/70\">Condition:</span> <span class=\"text-white\">${getWeatherDescription(data.hourly.weather_code[idx])}</span></div>\n                <div><span class=\"text-white/70\">Wind:</span> <span class=\"text-white\">${wind[i]} ${data.hourly_units.wind_speed_10m}</span></div>\n                <div><span class=\"text-white/70\">Humidity:</span> <span class=\"text-white\">${humidity[i]}${data.hourly_units.relative_humidity_2m}</span></div>\n                ${data.hourly.snowfall && snow[i] > 0 ? '' : (data.hourly.precipitation ? `<div><span class=\"text-white/70\">Precip:</span> <span class=\"text-white\">${precip[i]} ${data.hourly_units.precipitation || 'in'}</span></div>` : '')}\n                ${data.hourly.snowfall && snow[i] > 0 ? `<div><span class=\"text-white/70\">Snow:</span> <span class=\"text-white\">${snow[i]} ${data.hourly_units.snowfall || 'in'}</span></div>` : ''}\n                ${data.hourly.snowfall && snow[i] > 0 ? '' : (data.hourly.precipitation_probability ? `<div><span class=\"text-white/70\">Rain Chance:</span> <span class=\"text-white\">${data.hourly.precipitation_probability[idx]}%</span></div>` : '')}\n            </div>\n            <div class=\"mt-2 text-white/80 text-sm\">${getWeatherDescription(data.hourly.weather_code[idx])}</div>\n        `;\n        detailsContainer.appendChild(detailItem);\n    }\n}\n\nfunction openDailyModal(data) {\n    const modal = document.getElementById('dailyModal');\n    modal.classList.add('active');\n    \n    // Destroy existing charts if they exist\n    if (dailyChart) {\n        Object.values(dailyChart).forEach(chart => {\n            if (chart) chart.destroy();\n        });\n    }\n    \n    // Prepare data\n    const labels = [];\n    const maxTemps = [];\n    const minTemps = [];\n    const precip = [];\n    const snowfall = [];\n    const wind = [];\n    const precipProb = [];\n    \n    for (let i = 0; i < Math.min(7, data.daily.time.length); i++) {\n        const day = parseDateString(data.daily.time[i]);\n        labels.push(day.toLocaleDateString('en-US', { weekday: 'short' }));\n        maxTemps.push(Math.round(data.daily.temperature_2m_max[i]));\n        minTemps.push(Math.round(data.daily.temperature_2m_min[i]));\n        precip.push(data.daily.precipitation_sum[i] || 0);\n        snowfall.push(data.daily.snowfall_sum ? data.daily.snowfall_sum[i] || 0 : 0);\n        wind.push(data.daily.wind_speed_10m_max[i]);\n        precipProb.push(data.daily.precipitation_probability_max ? data.daily.precipitation_probability_max[i] : 0);\n    }\n    \n    // Create charts\n    const chartConfig = {\n        type: 'line',\n        options: {\n            responsive: true,\n            maintainAspectRatio: false,\n            plugins: {\n                legend: {\n                    labels: { color: '#fff' }\n                }\n            },\n            scales: {\n                x: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } },\n                y: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } }\n            }\n        }\n    };\n    \n    dailyChart = {\n        temp: new Chart(document.getElementById('dailyTempChart'), {\n            ...chartConfig,\n            data: {\n                labels,\n                datasets: [\n                    {\n                        label: `High (${data.daily_units.temperature_2m_max})`,\n                        data: maxTemps,\n                        borderColor: 'rgb(255, 99, 132)',\n                        backgroundColor: 'rgba(255, 99, 132, 0.2)',\n                        tension: 0.4\n                    },\n                    {\n                        label: `Low (${data.daily_units.temperature_2m_min})`,\n                        data: minTemps,\n                        borderColor: 'rgb(54, 162, 235)',\n                        backgroundColor: 'rgba(54, 162, 235, 0.2)',\n                        tension: 0.4\n                    }\n                ]\n            }\n        }),\n        precip: new Chart(document.getElementById('dailyPrecipChart'), {\n            ...chartConfig,\n            data: {\n                labels,\n                datasets: [{\n                    label: `Precipitation (${data.daily_units.precipitation_sum})`,\n                    data: precip,\n                    borderColor: 'rgb(54, 162, 235)',\n                    backgroundColor: 'rgba(54, 162, 235, 0.2)',\n                    tension: 0.4\n                }]\n            }\n        }),\n        wind: new Chart(document.getElementById('dailyWindChart'), {\n            ...chartConfig,\n            data: {\n                labels,\n                datasets: [{\n                    label: `Wind Speed (${data.daily_units.wind_speed_10m_max})`,\n                    data: wind,\n                    borderColor: 'rgb(255, 206, 86)',\n                    backgroundColor: 'rgba(255, 206, 86, 0.2)',\n                    tension: 0.4\n                }]\n            }\n        }),\n        snow: new Chart(document.getElementById('dailySnowChart'), {\n            ...chartConfig,\n            data: {\n                labels,\n                datasets: [{\n                    label: `Snowfall (${data.daily_units.snowfall_sum || 'in'})`,\n                    data: snowfall,\n                    borderColor: 'rgb(173, 216, 230)',\n                    backgroundColor: 'rgba(173, 216, 230, 0.3)',\n                    tension: 0.4,\n                    fill: true\n                }]\n            }\n        })\n    };\n    \n    // Hide/show charts based on snow presence\n    const snowChartContainer = document.getElementById('dailySnowChart').parentElement;\n    const precipChartContainer = document.getElementById('dailyPrecipChart').parentElement;\n    const hasSnow = snowfall.some(val => val > 0);\n    \n    if (hasSnow) {\n        snowChartContainer.style.display = 'block';\n        precipChartContainer.style.display = 'none';\n    } else {\n        snowChartContainer.style.display = 'none';\n        precipChartContainer.style.display = 'block';\n    }\n    \n    // Populate detailed daily items\n    const detailsContainer = document.getElementById('dailyDetails');\n    detailsContainer.innerHTML = '';\n    for (let i = 0; i < Math.min(7, data.daily.time.length); i++) {\n        const day = parseDateString(data.daily.time[i]);\n        const detailItem = document.createElement('div');\n        detailItem.className = 'bg-white/10 rounded-lg p-4 backdrop-blur-sm';\n        detailItem.innerHTML = `\n            <div class=\"flex items-center justify-between mb-3\">\n                <div>\n                    <div class=\"text-white font-semibold text-lg\">${day.toLocaleDateString('en-US', { weekday: 'long' })}</div>\n                    <div class=\"text-white/70 text-sm\">${day.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}</div>\n                </div>\n                <div class=\"text-4xl\">${getWeatherIcon(data.daily.weather_code[i])}</div>\n            </div>\n            <div class=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n                <div class=\"bg-white/10 rounded p-3\">\n                    <div class=\"text-white/70 text-xs mb-1\">High / Low</div>\n                    <div class=\"text-white font-bold\">${Math.round(maxTemps[i])}${data.daily_units.temperature_2m_max} / ${Math.round(minTemps[i])}${data.daily_units.temperature_2m_min}</div>\n                </div>\n                ${snowfall[i] > 0 ? `\n                <div class=\"bg-white/10 rounded p-3\">\n                    <div class=\"text-white/70 text-xs mb-1\"><i class=\"fas fa-snowflake mr-1\"></i>Snowfall</div>\n                    <div class=\"text-white font-bold\">${snowfall[i]} ${data.daily_units.snowfall_sum || 'in'}</div>\n                </div>\n                ` : `\n                <div class=\"bg-white/10 rounded p-3\">\n                    <div class=\"text-white/70 text-xs mb-1\">Precipitation</div>\n                    <div class=\"text-white font-bold\">${precip[i]} ${data.daily_units.precipitation_sum}</div>\n                </div>\n                `}\n                <div class=\"bg-white/10 rounded p-3\">\n                    <div class=\"text-white/70 text-xs mb-1\">Wind Speed</div>\n                    <div class=\"text-white font-bold\">${wind[i]} ${data.daily_units.wind_speed_10m_max}</div>\n                </div>\n                ${snowfall[i] > 0 ? '' : (precipProb[i] > 0 ? `\n                <div class=\"bg-white/10 rounded p-3\">\n                    <div class=\"text-white/70 text-xs mb-1\">Rain Chance</div>\n                    <div class=\"text-white font-bold\">${precipProb[i]}%</div>\n                </div>\n                ` : '')}\n            </div>\n            <div class=\"mt-3 text-white/80\">${getWeatherDescription(data.daily.weather_code[i])}</div>\n        `;\n        detailsContainer.appendChild(detailItem);\n    }\n}\n\n// Modal close handlers\ndocument.getElementById('closeHourlyModal').addEventListener('click', () => {\n    document.getElementById('hourlyModal').classList.remove('active');\n});\n\ndocument.getElementById('closeDailyModal').addEventListener('click', () => {\n    document.getElementById('dailyModal').classList.remove('active');\n});\n\n// Close modals when clicking outside\ndocument.getElementById('hourlyModal').addEventListener('click', (e) => {\n    if (e.target.id === 'hourlyModal') {\n        document.getElementById('hourlyModal').classList.remove('active');\n    }\n});\n\ndocument.getElementById('dailyModal').addEventListener('click', (e) => {\n    if (e.target.id === 'dailyModal') {\n        document.getElementById('dailyModal').classList.remove('active');\n    }\n});\n\n// Close modals with Escape key\ndocument.addEventListener('keydown', (e) => {\n    if (e.key === 'Escape') {\n        document.getElementById('hourlyModal').classList.remove('active');\n        document.getElementById('dailyModal').classList.remove('active');\n    }\n});\n\n// Weather Radar functionality\nfunction initializeRadar(lat, lon) {\n    // Initialize map if it doesn't exist (only for wind layer)\n    if (!radarMap) {\n        radarMap = L.map('radarMap', {\n            dragging: false,\n            touchZoom: false,\n            doubleClickZoom: false,\n            scrollWheelZoom: false,\n            boxZoom: false,\n            keyboard: false,\n            zoomControl: false\n        }).setView([lat, lon], 10);\n        \n        // Set view based on layer type\n        // For precipitation: 100 miles x 100 miles  1.44 degrees at mid-latitudes\n        // For wind: 10x10 miles (0.144 degrees)\n        let milesToDegrees;\n        if (currentRadarLayerType === 'precipitation') {\n            // 100 miles  1.44 degrees at mid-latitudes\n            milesToDegrees = 1.44;\n        } else {\n            // Wind: 10x10 miles\n            milesToDegrees = 0.144;\n        }\n        const halfSize = milesToDegrees / 2;\n        const bounds = [\n            [lat - halfSize, lon - halfSize],\n            [lat + halfSize, lon + halfSize]\n        ];\n        radarMap.fitBounds(bounds, { padding: [10, 10] });\n        \n        // Add base tile layer (dark theme)\n        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {\n            attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> &copy; <a href=\"https://carto.com/attributions\">CARTO</a>',\n            subdomains: 'abcd',\n            maxZoom: 19\n        }).addTo(radarMap);\n        \n        // Add marker for current location\n        L.marker([lat, lon], {\n            icon: L.divIcon({\n                className: 'custom-marker',\n                html: '<div style=\"background-color: #3b82f6; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);\"></div>',\n                iconSize: [20, 20],\n                iconAnchor: [10, 10]\n            })\n        }).addTo(radarMap);\n        \n        // Setup navigation buttons\n        setupRadarNavigation();\n    } else {\n        // Update map view based on layer type\n        // For precipitation: 100 miles x 100 miles  1.44 degrees at mid-latitudes\n        // For wind: 10x10 miles (0.144 degrees)\n        let milesToDegrees;\n        if (currentRadarLayerType === 'precipitation') {\n            // 100 miles  1.44 degrees at mid-latitudes\n            milesToDegrees = 1.44;\n        } else {\n            // Wind: 10x10 miles\n            milesToDegrees = 0.144;\n        }\n        const halfSize = milesToDegrees / 2;\n        const bounds = [\n            [lat - halfSize, lon - halfSize],\n            [lat + halfSize, lon + halfSize]\n        ];\n        radarMap.fitBounds(bounds, { padding: [10, 10] });\n        radarMap.eachLayer((layer) => {\n            if (layer instanceof L.Marker) {\n                radarMap.removeLayer(layer);\n            }\n        });\n        L.marker([lat, lon], {\n            icon: L.divIcon({\n                className: 'custom-marker',\n                html: '<div style=\"background-color: #3b82f6; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);\"></div>',\n                iconSize: [20, 20],\n                iconAnchor: [10, 10]\n            })\n        }).addTo(radarMap);\n    }\n    \n    // Fetch radar data\n    fetchNWSRadarData(lat, lon);\n    \n    // Update wind layer when map moves or zooms (if wind is active) - with debounce\n    if (radarMap) {\n        radarMap.on('moveend zoomend', () => {\n            // Clear existing timer\n            if (mapMoveDebounceTimer) {\n                clearTimeout(mapMoveDebounceTimer);\n            }\n            \n            // Set new timer - wait 2 seconds before making API call\n            mapMoveDebounceTimer = setTimeout(() => {\n                if (currentRadarLayerType === 'wind') {\n                    const currentFrame = radarFrames.length > 0 ? (radarFrames[currentRadarFrame] || radarFrames[radarFrames.length - 1]) : null;\n                    if (currentFrame && currentFrame.time) {\n                        fetchWindLayer(currentFrame.time);\n                    }\n                } else if (currentRadarLayerType === 'precipitation') {\n                    // Precipitation uses NWS tiles, update when map moves\n                    if (radarFrames.length > 0) {\n                        const currentFrame = radarFrames[currentRadarFrame] || radarFrames[radarFrames.length - 1];\n                        fetchPrecipitationRadar(currentFrame);\n                    }\n                }\n            }, 500); // 0.5 second delay\n        });\n    }\n}\n\nfunction setupRadarNavigation() {\n    // Zoom controls\n    document.getElementById('radarZoomIn').addEventListener('click', () => {\n        radarMap.zoomIn();\n        triggerMapUpdate();\n    });\n    \n    document.getElementById('radarZoomOut').addEventListener('click', () => {\n        radarMap.zoomOut();\n        triggerMapUpdate();\n    });\n    \n    // Pan controls (move by 25% of view in pixels)\n    document.getElementById('radarMoveUp').addEventListener('click', () => {\n        const mapSize = radarMap.getSize();\n        radarMap.panBy([0, -mapSize.y * 0.25]);\n        triggerMapUpdate();\n    });\n    \n    document.getElementById('radarMoveDown').addEventListener('click', () => {\n        const mapSize = radarMap.getSize();\n        radarMap.panBy([0, mapSize.y * 0.25]);\n        triggerMapUpdate();\n    });\n    \n    document.getElementById('radarMoveLeft').addEventListener('click', () => {\n        const mapSize = radarMap.getSize();\n        radarMap.panBy([-mapSize.x * 0.25, 0]);\n        triggerMapUpdate();\n    });\n    \n    document.getElementById('radarMoveRight').addEventListener('click', () => {\n        const mapSize = radarMap.getSize();\n        radarMap.panBy([mapSize.x * 0.25, 0]);\n        triggerMapUpdate();\n    });\n    \n    // Play/Pause animation button\n    const playPauseBtn = document.getElementById('radarPlayPause');\n    if (playPauseBtn) {\n        playPauseBtn.addEventListener('click', () => {\n            toggleRadarAnimation();\n        });\n    }\n}\n\nfunction triggerMapUpdate() {\n    // Manually trigger moveend event after a short delay to ensure map has updated\n    setTimeout(() => {\n        radarMap.fire('moveend');\n    }, 100);\n}\n\n// Generate time steps for NWS radar (10-minute intervals, past 1 hour to future 1 hour)\nfunction generateNWSTimeSteps() {\n    const now = new Date();\n    const steps = [];\n    const tenMinutes = 10 * 60 * 1000; // 10 minutes in milliseconds\n    \n    // NWS service provides data for past 4 hours up to current time\n    // Start 4 hours ago (rounded to nearest 10-minute interval)\n    const startTime = new Date(Math.floor((now.getTime() - (4 * 60 * 60 * 1000)) / tenMinutes) * tenMinutes);\n    // End at current time (rounded down to nearest 10-minute interval)\n    const endTime = new Date(Math.floor(now.getTime() / tenMinutes) * tenMinutes);\n    \n    // Generate steps at 10-minute intervals (only past times, not future)\n    let currentTime = startTime;\n    while (currentTime <= endTime) {\n        const unixTime = Math.floor(currentTime.getTime() / 1000);\n        const isoTime = currentTime.toISOString();\n        const epochTime = currentTime.getTime(); // Epoch milliseconds for NWS WMS\n        \n        steps.push({\n            time: unixTime,\n            isoTime: isoTime,\n            epochTime: epochTime, // Epoch milliseconds for NWS WMS time parameter\n            intensityPath: 'precipitationIntensity',\n            typePath: 'precipitationType',\n            precipitationTypes: new Set() // Will be populated when we fetch type data\n        });\n        \n        currentTime = new Date(currentTime.getTime() + tenMinutes);\n    }\n    \n    return steps;\n}\n\n// Fetch precipitation type for a specific tile to determine legend type\nasync function fetchPrecipitationTypeSample(lat, lon, isoTime, zoom = 8) {\n    try {\n        // Sample a few tiles around the center to determine precipitation type\n        // Use a small area around the location\n        const sampleTiles = [\n            { x: Math.floor((lon + 180) / 360 * Math.pow(2, zoom)) - 1, y: Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)) - 1 },\n            { x: Math.floor((lon + 180) / 360 * Math.pow(2, zoom)), y: Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)) },\n            { x: Math.floor((lon + 180) / 360 * Math.pow(2, zoom)) + 1, y: Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)) + 1 }\n        ];\n        \n        const types = new Set();\n        // We'll determine types from the actual tile data when available\n        // For now, return empty set - types will be determined from weather data\n        return types;\n    } catch (error) {\n        console.error('Error fetching precipitation type sample:', error);\n        return new Set();\n    }\n}\n\nasync function fetchNWSRadarData(lat, lon) {\n    try {\n        // Generate time steps at 10-minute intervals for NWS (past 1 hour to future 1 hour)\n        const timeSteps = generateNWSTimeSteps();\n        \n        if (timeSteps.length === 0) {\n            console.log('No time steps generated');\n            return;\n        }\n        \n        // Store frames for animation\n        radarFrames = timeSteps;\n        currentRadarFrame = Math.floor(timeSteps.length / 2); // Start at middle (current time)\n        \n        // Remove old radar layer if it exists\n        if (radarLayer) {\n            radarMap.removeLayer(radarLayer);\n        }\n        \n        // Update map view size based on current layer type (before loading data)\n        if (radarMap && lat && lon) {\n            let milesToDegrees;\n            if (currentRadarLayerType === 'precipitation') {\n                // 100 miles x 100 miles  1.44 degrees at mid-latitudes\n                milesToDegrees = 1.44;\n            } else {\n                // Wind: 10x10 miles\n                milesToDegrees = 0.144;\n            }\n            const halfSize = milesToDegrees / 2;\n            const bounds = [\n                [lat - halfSize, lon - halfSize],\n                [lat + halfSize, lon + halfSize]\n            ];\n            radarMap.fitBounds(bounds, { padding: [10, 10] });\n        }\n        \n        // Add the current frame\n        const currentFrame = radarFrames[currentRadarFrame];\n        if (currentFrame) {\n            updateRadarLayer(currentFrame);\n        }\n        \n    } catch (error) {\n        console.error('Error fetching NWS radar data:', error);\n    }\n}\n\n// Check if it's currently snowing based on weather data\nfunction isSnowing() {\n    if (!currentWeatherData) return false;\n    \n    // Check current weather code for snow conditions\n    const snowCodes = [71, 73, 75, 77, 85, 86]; // Slight snow, Moderate snow, Heavy snow, Snow grains, Slight snow showers, Heavy snow showers\n    const currentCode = currentWeatherData.current?.weather_code;\n    if (currentCode && snowCodes.includes(currentCode)) {\n        return true;\n    }\n    \n    // Also check if there's current snowfall in hourly data\n    if (currentWeatherData.hourly?.snowfall && currentWeatherData.hourly?.time) {\n        const now = new Date();\n        const currentHour = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), 0, 0);\n        \n        // Find the current hour in the hourly data\n        for (let i = 0; i < currentWeatherData.hourly.time.length; i++) {\n            const hourTime = new Date(currentWeatherData.hourly.time[i]);\n            if (hourTime.getTime() === currentHour.getTime()) {\n                const snowfall = currentWeatherData.hourly.snowfall[i] || 0;\n                const precipitation = currentWeatherData.hourly.precipitation[i] || 0;\n                // If snowfall is greater than precipitation, it's snowing\n                if (snowfall > 0 && snowfall >= precipitation) {\n                    return true;\n                }\n                break;\n            }\n        }\n    }\n    \n    return false;\n}\n\n// Get current precipitation rate (rain or snow) in in/hr\nfunction getCurrentPrecipitationRate() {\n    if (!currentWeatherData || !currentWeatherData.hourly) return 0;\n    \n    const now = new Date();\n    const currentHour = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), 0, 0);\n    \n    // Find the current hour in the hourly data\n    for (let i = 0; i < currentWeatherData.hourly.time.length; i++) {\n        const hourTime = new Date(currentWeatherData.hourly.time[i]);\n        if (hourTime.getTime() === currentHour.getTime()) {\n            const snowing = isSnowing();\n            if (snowing && currentWeatherData.hourly.snowfall) {\n                return currentWeatherData.hourly.snowfall[i] || 0;\n            } else if (currentWeatherData.hourly.precipitation) {\n                return currentWeatherData.hourly.precipitation[i] || 0;\n            }\n            break;\n        }\n    }\n    return 0;\n}\n\n// Get current wind speed in mph\nfunction getCurrentWindSpeed() {\n    if (!currentWeatherData || !currentWeatherData.current) return 0;\n    return currentWeatherData.current.wind_speed_10m || 0;\n}\n\n// Determine precipitation types for a given timestamp from weather data\nfunction getPrecipitationTypesForTime(timestamp) {\n    const types = new Set();\n    if (!currentWeatherData || !currentWeatherData.hourly) return types;\n    \n    const targetTime = new Date(timestamp * 1000);\n    const targetHour = new Date(targetTime.getFullYear(), targetTime.getMonth(), targetTime.getDate(), targetTime.getHours(), 0, 0);\n    \n    // Find the closest hour in hourly data\n    for (let i = 0; i < currentWeatherData.hourly.time.length; i++) {\n        const hourTime = new Date(currentWeatherData.hourly.time[i]);\n        if (hourTime.getTime() === targetHour.getTime()) {\n            const weatherCode = currentWeatherData.hourly.weather_code?.[i];\n            const snowfall = currentWeatherData.hourly.snowfall?.[i] || 0;\n            const precipitation = currentWeatherData.hourly.precipitation?.[i] || 0;\n            \n            // Determine type from weather code\n            if (weatherCode) {\n                // Snow codes: 71, 73, 75, 77, 85, 86\n                if ([71, 73, 75, 77, 85, 86].includes(weatherCode)) {\n                    types.add('snow');\n                }\n                // Rain codes: 51, 53, 55, 61, 63, 65, 80, 81, 82, 95, 96, 99\n                if ([51, 53, 55, 61, 63, 65, 80, 81, 82, 95, 96, 99].includes(weatherCode)) {\n                    types.add('rain');\n                }\n                // Freezing rain: 66, 67\n                if ([66, 67].includes(weatherCode)) {\n                    types.add('freezing_rain');\n                }\n                // Freezing drizzle: 56, 57\n                if ([56, 57].includes(weatherCode)) {\n                    types.add('freezing_drizzle');\n                }\n            }\n            \n            // Also check snowfall vs precipitation ratio\n            if (snowfall > 0 && snowfall >= precipitation * 0.5) {\n                types.add('snow');\n            } else if (precipitation > 0 && snowfall < precipitation * 0.5) {\n                types.add('rain');\n            }\n            \n            break;\n        }\n    }\n    \n    return types;\n}\n\n// Get precipitation types for current frame and surrounding frames\nfunction getPrecipitationTypesForFrames() {\n    const allTypes = new Set();\n    \n    if (radarFrames.length === 0) {\n        // Fallback to current weather data\n        const now = Math.floor(Date.now() / 1000);\n        const types = getPrecipitationTypesForTime(now);\n        types.forEach(type => allTypes.add(type));\n        return allTypes;\n    }\n    \n    // Check current frame and a few surrounding frames\n    const startIdx = Math.max(0, currentRadarFrame - 2);\n    const endIdx = Math.min(radarFrames.length - 1, currentRadarFrame + 2);\n    \n    for (let i = startIdx; i <= endIdx; i++) {\n        const frame = radarFrames[i];\n        if (frame && frame.time) {\n            const types = getPrecipitationTypesForTime(frame.time);\n            types.forEach(type => allTypes.add(type));\n        }\n    }\n    \n    return allTypes;\n}\n\n// Calculate position percentage on gradient bar (0-100%)\nfunction calculateMarkerPosition(value, min, max) {\n    if (value <= min) return 0;\n    if (value >= max) return 100;\n    return ((value - min) / (max - min)) * 100;\n}\n\n// Initialize legend based on current layer type and weather conditions\nfunction initializeLegend() {\n    const legend = document.getElementById('radarLegend');\n    if (!legend) {\n        return;\n    }\n    \n    if (currentRadarLayerType === 'wind') {\n        const windSpeed = getCurrentWindSpeed();\n        const position = calculateMarkerPosition(windSpeed, 0, 50);\n        \n        // For wind, show gradient bar with min/max - styled like controls\n        legend.innerHTML = `\n            <div class=\"flex items-center gap-2 bg-white/20 backdrop-blur-sm rounded-lg px-3 pt-4 pb-2 border border-white/30 overflow-visible\">\n                <span class=\"text-xs font-semibold text-white\">0</span>\n                <div class=\"relative w-32 h-3 rounded-full overflow-visible border border-white/20\">\n                    <div class=\"absolute inset-0 bg-gradient-to-r from-blue-300 via-cyan-400 via-green-400 via-yellow-400 via-orange-500 to-red-600 rounded-full\"></div>\n                    <div class=\"absolute top-1/2 -translate-y-1/2 -translate-x-1/2\" style=\"left: ${position}%; z-index: 10;\">\n                        <div class=\"absolute bottom-full left-1/2 -translate-x-1/2 mb-0.5 text-[9px] font-bold text-white whitespace-nowrap\" style=\"max-width: 32px; overflow: hidden; text-overflow: ellipsis;\">${windSpeed.toFixed(1)}</div>\n                        <div class=\"w-0.5 h-4 bg-white border border-white/50 shadow-lg\"></div>\n                    </div>\n                </div>\n                <span class=\"text-xs font-semibold text-white\">50+</span>\n                <span class=\"text-xs text-white/80 ml-1\">mph</span>\n            </div>\n        `;\n    } else if (currentRadarLayerType === 'precipitation') {\n        // Determine precipitation types from current and surrounding frames\n        const precipitationTypes = getPrecipitationTypesForFrames();\n        \n        // Determine legend type and labels\n        let unitLabel, icon, legendType;\n        if (precipitationTypes.has('snow') && !precipitationTypes.has('rain') && !precipitationTypes.has('freezing_rain') && !precipitationTypes.has('freezing_drizzle')) {\n            // Only snow\n            unitLabel = 'in/hr (snow)';\n            icon = '<i class=\"fas fa-snowflake text-blue-300 mr-1\"></i>';\n            legendType = 'snow';\n        } else if (precipitationTypes.has('rain') && !precipitationTypes.has('snow') && !precipitationTypes.has('freezing_rain') && !precipitationTypes.has('freezing_drizzle')) {\n            // Only rain\n            unitLabel = 'in/hr (rain)';\n            icon = '<i class=\"fas fa-tint text-blue-300 mr-1\"></i>';\n            legendType = 'rain';\n        } else if (precipitationTypes.size > 1 || precipitationTypes.has('freezing_rain') || precipitationTypes.has('freezing_drizzle')) {\n            // Mixed types\n            const typeLabels = [];\n            if (precipitationTypes.has('rain')) typeLabels.push('rain');\n            if (precipitationTypes.has('snow')) typeLabels.push('snow');\n            if (precipitationTypes.has('freezing_rain')) typeLabels.push('freezing rain');\n            if (precipitationTypes.has('freezing_drizzle')) typeLabels.push('freezing drizzle');\n            unitLabel = `in/hr (${typeLabels.join(', ')})`;\n            icon = '<i class=\"fas fa-cloud-rain text-blue-300 mr-1\"></i>';\n            legendType = 'mixed';\n        } else {\n            // Default to rain if unclear\n            unitLabel = 'in/hr (rain)';\n            icon = '<i class=\"fas fa-tint text-blue-300 mr-1\"></i>';\n            legendType = 'rain';\n        }\n        \n        const rate = getCurrentPrecipitationRate();\n        \n        // Precipitation scale: 0, 0.02, 0.08, 0.4, 1.6, 2+\n        // Use logarithmic-like positioning for better distribution\n        let position = 0;\n        if (rate <= 0) {\n            position = 0;\n        } else if (rate <= 0.02) {\n            position = (rate / 0.02) * (100 / 6); // First segment: 0-16.67%\n        } else if (rate <= 0.08) {\n            position = 16.67 + ((rate - 0.02) / 0.06) * (100 / 6); // Second segment: 16.67-33.33%\n        } else if (rate <= 0.4) {\n            position = 33.33 + ((rate - 0.08) / 0.32) * (100 / 6); // Third segment: 33.33-50%\n        } else if (rate <= 1.6) {\n            position = 50 + ((rate - 0.4) / 1.2) * (100 / 6); // Fourth segment: 50-66.67%\n        } else if (rate <= 2) {\n            position = 66.67 + ((rate - 1.6) / 0.4) * (100 / 6); // Fifth segment: 66.67-83.33%\n        } else {\n            position = 83.33 + Math.min(((rate - 2) / 2) * (100 / 6), 16.67); // Sixth segment: 83.33-100%\n        }\n        position = Math.min(100, Math.max(0, position));\n        \n        // For precipitation, show gradient bar with labels - styled like controls\n        legend.innerHTML = `\n            <div class=\"flex flex-col gap-1.5 bg-white/20 backdrop-blur-sm rounded-lg px-3 pt-4 pb-2 border border-white/30 overflow-visible\">\n                <div class=\"relative w-48 h-3 rounded-full overflow-visible border border-white/20\">\n                    <div class=\"absolute inset-0 bg-gradient-to-r from-blue-400 via-cyan-400 via-green-400 via-yellow-400 via-orange-500 to-red-600 rounded-full\"></div>\n                    <div class=\"absolute top-1/2 -translate-y-1/2 -translate-x-1/2\" style=\"left: ${position}%; z-index: 10;\">\n                        <div class=\"absolute bottom-full left-1/2 -translate-x-1/2 mb-0.5 text-[9px] font-bold text-white whitespace-nowrap\" style=\"max-width: 48px; overflow: hidden; text-overflow: ellipsis;\">${rate.toFixed(1)}</div>\n                        <div class=\"w-0.5 h-4 bg-white border border-white/50 shadow-lg\"></div>\n                    </div>\n                </div>\n                <div class=\"flex items-center justify-between text-[10px] text-white/90 font-medium\">\n                    <span>0</span>\n                    <span>0.02</span>\n                    <span>0.08</span>\n                    <span>0.4</span>\n                    <span>1.6</span>\n                    <span>2+</span>\n                </div>\n                <div class=\"text-center\">\n                    <span class=\"text-[10px] font-semibold text-white/90\">${icon}${unitLabel}</span>\n                </div>\n            </div>\n        `;\n    }\n}\n\n// Radar layer switching\nfunction updateRadarLayer(frame) {\n    // #region agent log\n    fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:1592',message:'updateRadarLayer called',data:{layerType:currentRadarLayerType,hasFrame:!!frame,framePath:frame?.path,radarFramesLength:radarFrames.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run2',hypothesisId:'H'})}).catch(()=>{});\n    // #endregion\n    // For precipitation, we need a frame with path\n    if (currentRadarLayerType === 'precipitation') {\n        if (!currentLat || !currentLon) {\n            // #region agent log\n            fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:1595',message:'updateRadarLayer precipitation - no lat/lon, returning',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run2',hypothesisId:'H'})}).catch(()=>{});\n            // #endregion\n            return;\n        }\n        if (!frame || !frame.epochTime) {\n            // Try to get frame from radarFrames\n            if (radarFrames.length > 0) {\n                frame = radarFrames[currentRadarFrame] || radarFrames[0];\n            } else {\n                // #region agent log\n                fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:1601',message:'updateRadarLayer precipitation - no frame, returning early',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run2',hypothesisId:'H'})}).catch(()=>{});\n                // #endregion\n                return;\n            }\n        }\n    } else if (currentRadarLayerType === 'wind') {\n        // Wind doesn't need frame - it fetches current data\n        // Allow to proceed even without frame\n    } else if (!frame) {\n        return;\n    }\n    \n    // Remove existing layers\n    if (radarLayer) {\n        radarMap.removeLayer(radarLayer);\n        radarLayer = null;\n    }\n    \n    // Clear wind layer if switching away from wind\n    if (currentRadarLayerType !== 'wind') {\n        if (windCanvasLayer) {\n            radarMap.removeLayer(windCanvasLayer);\n            windCanvasLayer = null;\n        }\n        windMarkers.forEach(marker => radarMap.removeLayer(marker));\n        windMarkers = [];\n    }\n    \n    // Rain and snow use NWS tiles, no canvas layer needed\n    \n    if (currentRadarLayerType === 'wind') {\n        // For wind, show Leaflet map and hide iframe\n        const mapContainer = document.getElementById('radarMap');\n        const iframeContainer = document.getElementById('radarIframeContainer');\n        // #region agent log\n        fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:1630',message:'Updating radar map display for wind',data:{mapContainerExists:!!mapContainer,mapDisplayBefore:mapContainer?.style?.display},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});\n        // #endregion\n        if (mapContainer) mapContainer.style.display = 'block';\n        if (iframeContainer) iframeContainer.style.display = 'none';\n        // #region agent log\n        fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:1634',message:'Map display updated for wind',data:{mapDisplayAfter:mapContainer?.style?.display,legendExists:!!document.getElementById('radarLegend'),legendDisplay:document.getElementById('radarLegend')?.style?.display},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});\n        // #endregion\n        \n        \n        // Invalidate map size to ensure it renders correctly after being hidden\n        if (radarMap) {\n            setTimeout(() => {\n                radarMap.invalidateSize();\n                // Ensure map is centered on current location\n                if (currentLat && currentLon) {\n                    const milesToDegrees = 0.144; // 10x10 miles\n                    const halfSize = milesToDegrees / 2;\n                    const bounds = [\n                        [currentLat - halfSize, currentLon - halfSize],\n                        [currentLat + halfSize, currentLon + halfSize]\n                    ];\n                    radarMap.fitBounds(bounds, { padding: [10, 10] });\n                }\n            }, 100);\n        }\n        \n        // Fetch and display wind vectors across the map\n        fetchWindLayer(frame ? frame.time : null);\n    } else if (currentRadarLayerType === 'precipitation') {\n        // Precipitation radar - use NWS tiles with Leaflet\n        // Show Leaflet map, hide iframe\n        const mapContainer = document.getElementById('radarMap');\n        const iframeContainer = document.getElementById('radarIframeContainer');\n        // #region agent log\n        fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:1673',message:'Updating radar map display for precipitation',data:{mapContainerExists:!!mapContainer,mapDisplayBefore:mapContainer?.style?.display},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});\n        // #endregion\n        if (mapContainer) mapContainer.style.display = 'block';\n        if (iframeContainer) iframeContainer.style.display = 'none';\n        // #region agent log\n        fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:1681',message:'Map display updated for precipitation',data:{mapDisplayAfter:mapContainer?.style?.display,legendExists:!!document.getElementById('radarLegend'),legendDisplay:document.getElementById('radarLegend')?.style?.display},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});\n        // #endregion\n        \n        // Initialize legend when map is shown\n        initializeLegend();\n        \n        \n        // Invalidate map size to ensure it renders correctly after being hidden\n        if (radarMap) {\n            setTimeout(() => {\n                radarMap.invalidateSize();\n                // Ensure map is centered on current location with 100x100 mile view\n                if (currentLat && currentLon) {\n                    const milesToDegrees = 1.44; // 100x100 miles\n                    const halfSize = milesToDegrees / 2;\n                    const bounds = [\n                        [currentLat - halfSize, currentLon - halfSize],\n                        [currentLat + halfSize, currentLon + halfSize]\n                    ];\n                    radarMap.fitBounds(bounds, { padding: [10, 10] });\n                }\n            }, 100);\n        }\n        \n        // Fetch and display precipitation radar tiles\n        fetchPrecipitationRadar(frame);\n    }\n}\n\nasync function fetchWindLayer(timestamp) {\n    if (!currentLat || !currentLon || !radarMap) return;\n    \n    // Get map bounds to create a dense grid for streamlines\n    const bounds = radarMap.getBounds();\n    \n    // Check if we can reuse cached data (if bounds haven't changed much)\n    if (windDataCache && windDataCache.bounds && windDataCache.timestamp) {\n        const cachedBounds = windDataCache.bounds;\n        const boundsChanged = \n            Math.abs(cachedBounds.getNorth() - bounds.getNorth()) > 0.01 ||\n            Math.abs(cachedBounds.getSouth() - bounds.getSouth()) > 0.01 ||\n            Math.abs(cachedBounds.getEast() - bounds.getEast()) > 0.01 ||\n            Math.abs(cachedBounds.getWest() - bounds.getWest()) > 0.01;\n        \n        // If bounds haven't changed much and cache is less than 5 minutes old, reuse it\n        const cacheAge = Date.now() - windDataCache.timestamp;\n        if (!boundsChanged && cacheAge < 5 * 60 * 1000) {\n            console.log('Reusing cached wind data');\n            windGridData = windDataCache;\n            createWindStreamlines(windGridData, bounds, 8);\n            return;\n        }\n    }\n    \n    // Clear existing wind visualization\n    windMarkers.forEach(marker => radarMap.removeLayer(marker));\n    windMarkers = [];\n    if (windCanvasLayer) {\n        radarMap.removeLayer(windCanvasLayer);\n        windCanvasLayer = null;\n    }\n    \n    try {\n        \n        // Create a moderate grid (8x8 = 64 points) to reduce API calls\n        // We use interpolation to create smooth streamlines from fewer data points\n        const gridSize = 8;\n        const latStep = (bounds.getNorth() - bounds.getSouth()) / (gridSize - 1);\n        const lonStep = (bounds.getEast() - bounds.getWest()) / (gridSize - 1);\n        \n        const gridPoints = [];\n        for (let i = 0; i < gridSize; i++) {\n            for (let j = 0; j < gridSize; j++) {\n                const lat = bounds.getSouth() + (i * latStep);\n                const lon = bounds.getWest() + (j * lonStep);\n                gridPoints.push({ lat, lon, gridI: i, gridJ: j });\n            }\n        }\n        \n        // Fetch only current wind data (no time series needed)\n        const windPromises = gridPoints.map(async (point, pointIndex) => {\n            // Small delay to avoid rate limiting\n            if (pointIndex > 0) {\n                await new Promise(resolve => setTimeout(resolve, pointIndex * 10));\n            }\n            \n            try {\n                const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${point.lat}&longitude=${point.lon}&current=wind_speed_10m,wind_direction_10m&windspeed_unit=mph&timezone=auto`);\n                const data = await response.json();\n                \n                if (data.current && data.current.wind_speed_10m !== undefined && data.current.wind_direction_10m !== undefined) {\n                    const windSpeed = data.current.wind_speed_10m || 0;\n                    const windDirection = data.current.wind_direction_10m || 0;\n                    \n                    // Convert direction to radians and calculate u/v components\n                    const dirRad = (windDirection * Math.PI) / 180;\n                    const u = -windSpeed * Math.sin(dirRad);\n                    const v = -windSpeed * Math.cos(dirRad);\n                    \n                    return {\n                        lat: point.lat,\n                        lon: point.lon,\n                        gridI: point.gridI,\n                        gridJ: point.gridJ,\n                        speed: windSpeed,\n                        direction: windDirection,\n                        u: u,\n                        v: v\n                    };\n                }\n            } catch (error) {\n                console.error(`Error fetching wind for point ${pointIndex}:`, error);\n            }\n            return null;\n        });\n        \n        const windData = await Promise.all(windPromises);\n        \n        // Filter out null values\n        const validWindData = windData.filter(d => d !== null);\n        \n        // Use current wind data\n        windGridData = validWindData;\n        \n        // Create canvas layer for streamlines\n        createWindStreamlines(windGridData, bounds, gridSize);\n        \n        // Store wind data\n        windDataCache = windGridData;\n        \n        // Mark that we have wind data cached\n        windDataCache.bounds = bounds;\n        windDataCache.timestamp = Date.now();\n        \n    } catch (error) {\n        console.error('Error fetching wind data:', error);\n    }\n}\n\n// Fetch and display precipitation radar using NWS WMS tiles\nasync function fetchPrecipitationRadar(frame) {\n    if (!currentLat || !currentLon || !radarMap) return;\n    \n    // Remove existing radar layer\n    if (radarLayer) {\n        radarMap.removeLayer(radarLayer);\n        radarLayer = null;\n    }\n    \n    try {\n        // Get the frame to use if not provided\n        let frameToUse = frame;\n        if (!frameToUse) {\n            // Use current frame or first available frame\n            if (radarFrames.length > 0) {\n                frameToUse = radarFrames[currentRadarFrame] || radarFrames[0];\n            } else {\n                console.log('No radar frames available');\n                return;\n            }\n        }\n        \n        // Ensure we have a valid frame with epochTime\n        if (!frameToUse || !frameToUse.epochTime) {\n            console.log('No valid frame with epochTime available');\n            return;\n        }\n        \n        // #region agent log\n        console.log('DEBUG: Creating NWS WMS layer - frame data', {epochTime:frameToUse.epochTime,isoTime:frameToUse.isoTime,time:frameToUse.time,epochTimeStr:frameToUse.epochTime.toString()});\n        fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:2221',message:'Creating NWS WMS layer - frame data',data:{epochTime:frameToUse.epochTime,isoTime:frameToUse.isoTime,time:frameToUse.time,epochTimeStr:frameToUse.epochTime.toString()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});\n        // #endregion\n        \n        // NWS WMS endpoint - try direct connection first (images don't have CORS restrictions)\n        // If this doesn't work, we can fall back to proxy\n        const wmsUrl = 'https://opengeo.ncep.noaa.gov/geoserver/ows';\n        \n        // Build WMS options - try without time first since time parameter is causing errors\n        // NWS service returns most recent data when time is omitted\n        const wmsOptions = {\n            layers: 'conus:conus_bref_qcd', // CONUS base reflectivity layer from RIDGE2\n            format: 'image/png',\n            transparent: true,\n            opacity: 0.7,\n            attribution: 'NWS',\n            zIndex: 1000,\n            // Temporarily omit time parameter - NWS returns most recent when omitted\n            // TODO: Fix time parameter format for animation support\n            // time: frameToUse.epochTime.toString(), // Time parameter in epoch milliseconds for NWS WMS\n            version: '1.3.0',\n            // Don't specify CRS - let Leaflet use the map's default CRS (EPSG:3857)\n            // The layer supports both EPSG:3857 and EPSG:4326, and EPSG:3857 returns larger/better images\n            uppercase: true // Some WMS servers require uppercase parameters\n        };\n        \n        // #region agent log\n        console.log('DEBUG: WMS layer options before creation', {wmsOptions:wmsOptions,wmsUrl:wmsUrl});\n        fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:2234',message:'WMS layer options before creation',data:{wmsOptions:wmsOptions,wmsUrl:wmsUrl},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});\n        // #endregion\n        \n        // Create WMS layer for radar reflectivity\n        // NWS requires time in epoch milliseconds format\n        radarLayer = L.tileLayer.wms(wmsUrl, wmsOptions);\n        \n        // #region agent log\n        fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:2242',message:'WMS layer created - checking wmsParams',data:{hasWmsParams:!!radarLayer.wmsParams,wmsParams:radarLayer.wmsParams},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});\n        // #endregion\n        \n        // Add error handler - capture detailed error information\n        radarLayer.on('tileerror', function(error, tile) {\n            // #region agent log\n            // Try to extract more information from the error\n            let tileSrc = null;\n            let tileCoords = null;\n            try {\n                if (tile) {\n                    tileSrc = tile.src || tile.getAttribute?.('src') || null;\n                    tileCoords = tile.coords || null;\n                }\n            } catch (e) {}\n            \n            // Try to fetch the failed tile to see what's actually being returned\n            if (tileSrc) {\n                fetch(tileSrc).then(r => r.arrayBuffer()).then(buffer => {\n                    const bytes = new Uint8Array(buffer.slice(0, 8));\n                    const isPNG = bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47;\n                    const textDecoder = new TextDecoder();\n                    const textStart = textDecoder.decode(buffer.slice(0, 100));\n                    console.log('DEBUG: Failed tile analysis', {\n                        url:tileSrc,\n                        dataSize:buffer.byteLength,\n                        isPNG:isPNG,\n                        firstBytes:Array.from(bytes),\n                        textStart:textStart.substring(0, 100)\n                    });\n                }).catch(e => {\n                    console.log('DEBUG: Failed to analyze tile', {error:e.message,url:tileSrc});\n                });\n            }\n            \n            const errorData = {\n                hasError: !!error,\n                errorType: error?.type,\n                errorMessage: error?.error?.message,\n                errorStack: error?.error?.stack,\n                tileSrc: tileSrc,\n                tileCoords: tileCoords,\n                tileObject: tile ? Object.keys(tile) : null,\n                errorObject: error ? Object.keys(error) : null,\n                fullError: error ? JSON.stringify(error, Object.getOwnPropertyNames(error)) : null\n            };\n            console.log('DEBUG: NWS tile error', errorData);\n            console.log('DEBUG: Tile object:', tile);\n            console.log('DEBUG: Error object:', error);\n            fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:2250',message:'NWS tile error occurred',data:errorData,timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});\n            // #endregion\n            \n            // Suppress errors for missing tiles which are expected\n            // Only log if it's not a common CORS/network issue\n            if (error && error.error && error.error.message && !error.error.message.includes('Failed to fetch')) {\n                console.log('NWS tile error (suppressed):', error);\n            }\n        });\n        \n        // Monitor tile loading to capture request URLs\n        radarLayer.on('tileloadstart', function(event) {\n            // #region agent log\n            let tileSrc = null;\n            try {\n                if (event.tile) {\n                    tileSrc = event.tile.src || event.tile.getAttribute?.('src') || null;\n                    // Also try to get it from the img element directly\n                    if (!tileSrc && event.tile.tagName === 'IMG') {\n                        tileSrc = event.tile.src;\n                    }\n                }\n            } catch (e) {}\n            console.log('DEBUG: Tile load started', {tileSrc:tileSrc,coords:event.coords,eventKeys:Object.keys(event)});\n            // Try to fetch the tile URL directly to see what's being requested and validate the image\n            if (tileSrc) {\n                fetch(tileSrc).then(r => r.arrayBuffer()).then(buffer => {\n                    const bytes = new Uint8Array(buffer.slice(0, 8));\n                    const isPNG = bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47;\n                    console.log('DEBUG: Direct tile fetch response', {\n                        status:200,\n                        contentType:'image/png',\n                        url:tileSrc,\n                        dataSize:buffer.byteLength,\n                        isPNG:isPNG,\n                        firstBytes:Array.from(bytes)\n                    });\n                }).catch(e => {\n                    console.log('DEBUG: Direct tile fetch error', {error:e.message,url:tileSrc});\n                });\n            }\n            fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:2265',message:'Tile load started',data:{tileSrc:tileSrc,coords:event.coords},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});\n            // #endregion\n        });\n        \n        // Monitor successful tile loads\n        radarLayer.on('tileload', function(event) {\n            // #region agent log\n            let tileSrc = null;\n            try {\n                if (event.tile) {\n                    tileSrc = event.tile.src || event.tile.getAttribute?.('src') || null;\n                }\n            } catch (e) {}\n            console.log('DEBUG: Tile loaded successfully', {tileSrc:tileSrc,coords:event.coords});\n            fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:2275',message:'Tile loaded successfully',data:{tileSrc:tileSrc,coords:event.coords},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});\n            // #endregion\n        });\n        \n        radarLayer.addTo(radarMap);\n        console.log('Added NWS precipitation layer for time:', frameToUse.isoTime);\n        \n        // Update time display\n        updateRadarTimeDisplay(frameToUse.time);\n        \n        // Update legend based on precipitation type\n        initializeLegend();\n        \n    } catch (error) {\n        console.error('Error fetching NWS precipitation radar:', error);\n    }\n}\n\n// Update radar frame display with smooth transition\nfunction updateRadarFrame(frame) {\n    if (!frame || !frame.epochTime || !radarMap) return;\n    \n    // Update the WMS layer with new frame using smooth opacity transition\n    // Note: Time parameter is currently disabled due to format issues\n    // For now, just refresh the layer to show most recent data\n    if (radarLayer && radarLayer.wmsParams) {\n        // Fade out old layer\n        radarLayer.setOpacity(0);\n        \n        // After fade, refresh the layer (time parameter disabled for now)\n        setTimeout(() => {\n            if (radarLayer && radarLayer.wmsParams) {\n                // Time parameter temporarily disabled - just refresh layer\n                // radarLayer.wmsParams.time = frame.epochTime.toString();\n                radarLayer.setParams(radarLayer.wmsParams);\n                \n                // Fade in new layer smoothly\n                setTimeout(() => {\n                    if (radarLayer) {\n                        radarLayer.setOpacity(0.7);\n                    }\n                }, 50);\n            }\n        }, 200); // Wait for fade out\n    } else if (!radarLayer) {\n        // If layer doesn't exist, create it\n        fetchPrecipitationRadar(frame);\n    }\n    \n    // Update time display\n    updateRadarTimeDisplay(frame.time);\n    \n    // Update legend based on precipitation type for this frame\n    initializeLegend();\n}\n\n// Update the time display for current frame\nfunction updateRadarTimeDisplay(timestamp) {\n    const timeDisplay = document.getElementById('radarTimeDisplay');\n    const timeText = document.getElementById('radarTimeText');\n    \n    if (timeDisplay && timeText && timestamp) {\n        // Convert timestamp (Unix timestamp in seconds) to Date\n        const date = new Date(timestamp * 1000);\n        const timeStr = formatTime12Hour(date);\n        timeText.textContent = timeStr;\n        timeDisplay.classList.remove('hidden');\n    }\n}\n\n// Play/pause radar animation with smooth transitions\nlet lastFrameTime = 0;\nconst FRAME_DURATION = 1500; // 1.5 seconds per frame for slower, smoother animation\n\nfunction animateRadarFrame(currentTime) {\n    if (!isRadarAnimating || currentRadarLayerType !== 'precipitation') {\n        radarAnimationFrame = null;\n        return;\n    }\n    \n    // Use requestAnimationFrame for smooth timing\n    if (currentTime - lastFrameTime >= FRAME_DURATION) {\n        if (radarFrames.length === 0) {\n            isRadarAnimating = false;\n            radarAnimationFrame = null;\n            return;\n        }\n        \n        // Move to next frame\n        if (currentRadarFrame < radarFrames.length - 1) {\n            currentRadarFrame = currentRadarFrame + 1;\n        } else {\n            // Reached the end - reset to current time (frame 0) and stop animation\n            currentRadarFrame = 0;\n            const frame = radarFrames[currentRadarFrame];\n            updateRadarFrame(frame);\n            toggleRadarAnimation();\n            return;\n        }\n        const frame = radarFrames[currentRadarFrame];\n        \n        // Update frame with smooth transition\n        updateRadarFrame(frame);\n        \n        lastFrameTime = currentTime;\n    }\n    \n    // Continue animation loop\n    radarAnimationFrame = requestAnimationFrame(animateRadarFrame);\n}\n\nfunction toggleRadarAnimation() {\n    if (currentRadarLayerType !== 'precipitation') {\n        return; // Only animate precipitation layer\n    }\n    \n    if (isRadarAnimating) {\n        // Pause animation\n        if (radarAnimationFrame) {\n            cancelAnimationFrame(radarAnimationFrame);\n            radarAnimationFrame = null;\n        }\n        if (radarAnimationInterval) {\n            clearInterval(radarAnimationInterval);\n            radarAnimationInterval = null;\n        }\n        isRadarAnimating = false;\n        \n        // Update button icon\n        const playPauseBtn = document.getElementById('radarPlayPause');\n        if (playPauseBtn) {\n            const icon = playPauseBtn.querySelector('i');\n            if (icon) {\n                icon.classList.remove('fa-pause');\n                icon.classList.add('fa-play');\n            }\n            playPauseBtn.title = 'Play Animation';\n        }\n    } else {\n        // Start animation\n        if (radarFrames.length === 0) {\n            console.log('No radar frames available for animation');\n            return;\n        }\n        \n        isRadarAnimating = true;\n        lastFrameTime = performance.now();\n        \n        // Update button icon\n        const playPauseBtn = document.getElementById('radarPlayPause');\n        if (playPauseBtn) {\n            const icon = playPauseBtn.querySelector('i');\n            if (icon) {\n                icon.classList.remove('fa-play');\n                icon.classList.add('fa-pause');\n            }\n            playPauseBtn.title = 'Pause Animation';\n        }\n        \n        // Show time display\n        const timeDisplay = document.getElementById('radarTimeDisplay');\n        if (timeDisplay) {\n            timeDisplay.classList.remove('hidden');\n        }\n        \n        // Update initial time display\n        if (radarFrames.length > 0) {\n            const currentFrame = radarFrames[currentRadarFrame] || radarFrames[radarFrames.length - 1];\n            if (currentFrame && currentFrame.time) {\n                updateRadarTimeDisplay(currentFrame.time);\n            }\n        }\n        \n        // Start smooth animation loop using requestAnimationFrame\n        radarAnimationFrame = requestAnimationFrame(animateRadarFrame);\n    }\n}\n\nfunction createWindStreamlines(windData, bounds, gridSize) {\n    // Remove existing canvas layer and stop animation\n    if (windCanvasLayer) {\n        radarMap.removeLayer(windCanvasLayer);\n        windCanvasLayer = null;\n    }\n    \n    // Create canvas element\n    const canvas = document.createElement('canvas');\n    canvas.style.position = 'absolute';\n    canvas.style.top = '0';\n    canvas.style.left = '0';\n    canvas.style.pointerEvents = 'none';\n    canvas.style.zIndex = '1001';\n    const ctx = canvas.getContext('2d');\n    \n    // Store wind data reference for animation updates\n    let currentWindData = windData;\n    let pulseOffset = 0; // Animation offset for pulsing effect\n    let isAnimating = false;\n    let cachedStreamlines = null; // Cache generated streamlines to avoid regenerating every frame\n    \n    // Function to interpolate wind vector at any point using bilinear interpolation\n    function getWindAtPoint(lat, lon, data = currentWindData) {\n        if (!data || data.length === 0) return null;\n        \n        // Find the 4 nearest points for bilinear interpolation\n        const neighbors = [];\n        data.forEach(wind => {\n            const dist = Math.sqrt(\n                Math.pow(wind.lat - lat, 2) + \n                Math.pow(wind.lon - lon, 2)\n            );\n            neighbors.push({ ...wind, dist });\n        });\n        \n        // Sort by distance\n        neighbors.sort((a, b) => a.dist - b.dist);\n        \n        // Use the nearest point if within reasonable distance (much larger threshold)\n        const nearest = neighbors[0];\n        if (nearest && nearest.dist < 1.0) { // Very large threshold to ensure we always get data\n            return { u: nearest.u, v: nearest.v, speed: nearest.speed || 0 };\n        }\n        \n        // If we have at least 2 neighbors, do weighted interpolation\n        if (neighbors.length >= 2) {\n            const n1 = neighbors[0];\n            const n2 = neighbors[1];\n            \n            // Use inverse distance weighting\n            const w1 = 1 / (n1.dist + 0.001);\n            const w2 = 1 / (n2.dist + 0.001);\n            const totalWeight = w1 + w2;\n            \n            const u = (n1.u * w1 + n2.u * w2) / totalWeight;\n            const v = (n1.v * w1 + n2.v * w2) / totalWeight;\n            const speed = (n1.speed * w1 + n2.speed * w2) / totalWeight;\n            \n            return { u, v, speed: speed || 0 };\n        }\n        \n        // If we have at least 4 neighbors, do bilinear interpolation\n        if (neighbors.length >= 4) {\n            const n1 = neighbors[0];\n            const n2 = neighbors[1];\n            const n3 = neighbors[2];\n            const n4 = neighbors[3];\n            \n            // Simple weighted average\n            const w1 = 1 / (n1.dist + 0.001);\n            const w2 = 1 / (n2.dist + 0.001);\n            const w3 = 1 / (n3.dist + 0.001);\n            const w4 = 1 / (n4.dist + 0.001);\n            const totalWeight = w1 + w2 + w3 + w4;\n            \n            const u = (n1.u * w1 + n2.u * w2 + n3.u * w3 + n4.u * w4) / totalWeight;\n            const v = (n1.v * w1 + n2.v * w2 + n3.v * w3 + n4.v * w4) / totalWeight;\n            const speed = (n1.speed * w1 + n2.speed * w2 + n3.speed * w3 + n4.speed * w4) / totalWeight;\n            \n            return { u, v, speed: speed || 0 };\n        }\n        \n        // Always return something, even if far away\n        if (nearest) {\n            return { u: nearest.u, v: nearest.v, speed: nearest.speed || 0 };\n        }\n        \n        return null;\n    }\n    \n    // Function to trace a long, continuous streamline\n    function traceStreamline(startLat, startLon, forward = true, data = currentWindData) {\n        const points = [];\n        \n        // Get current zoom level to adjust step size for consistent screen length\n        const zoom = radarMap.getZoom();\n        // Base step size in pixels - this will remain constant on screen\n        const pixelStepSize = 3; // pixels per step\n        // Convert pixel step to geographic step based on zoom level\n        // At zoom level z, 1 degree  256 * 2^z pixels at equator (Web Mercator approximation)\n        // Adjust for latitude\n        const metersPerPixel = (40075017 / (256 * Math.pow(2, zoom))) * Math.cos(startLat * Math.PI / 180);\n        const degreesPerPixel = metersPerPixel / 111320; // approximate meters per degree\n        const stepSize = pixelStepSize * degreesPerPixel;\n        \n        let currentLat = startLat;\n        let currentLon = startLon;\n        const maxSteps = 1000; // More steps for longer lines\n        \n        // Track visited areas to avoid loops (very loose)\n        const visited = new Set();\n        const visitKey = (lat, lon) => `${Math.round(lat * 10)}_${Math.round(lon * 10)}`; // Very loose precision\n        \n        let lastWind = null;\n        let consecutiveFailures = 0;\n        \n        for (let step = 0; step < maxSteps; step++) {\n            const wind = getWindAtPoint(currentLat, currentLon, data);\n            \n            if (!wind) {\n                consecutiveFailures++;\n                // Use last known wind direction if available\n                if (lastWind && consecutiveFailures < 10) {\n                    const magnitude = Math.sqrt(lastWind.u * lastWind.u + lastWind.v * lastWind.v);\n                    if (magnitude > 0.001) {\n                        const uNorm = lastWind.u / magnitude;\n                        const vNorm = lastWind.v / magnitude;\n                        \n                        // Use pixel-based step size\n                        const latStep = (vNorm * stepSize * (forward ? 1 : -1));\n                        const lonStep = (uNorm * stepSize * (forward ? 1 : -1)) / Math.cos(currentLat * Math.PI / 180);\n                        \n                        currentLat += latStep;\n                        currentLon += lonStep;\n                    } else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            } else {\n                lastWind = wind;\n                consecutiveFailures = 0;\n                const speed = wind.speed || 0;\n                \n                // Normalize direction\n                const magnitude = Math.sqrt(wind.u * wind.u + wind.v * wind.v);\n                if (magnitude < 0.001) {\n                    // Very weak wind, use a default direction\n                    break;\n                }\n                \n                const uNorm = wind.u / magnitude;\n                const vNorm = wind.v / magnitude;\n                \n                // Convert to lat/lon step using pixel-based step size\n                const latStep = (vNorm * stepSize * (forward ? 1 : -1));\n                const lonStep = (uNorm * stepSize * (forward ? 1 : -1)) / Math.cos(currentLat * Math.PI / 180);\n                \n                currentLat += latStep;\n                currentLon += lonStep;\n            }\n            \n            // Check for loops (very loose - only break on exact repeats after many points)\n            const key = visitKey(currentLat, currentLon);\n            if (visited.has(key) && points.length > 50) {\n                // Only break if we've traced a long way and hit a loop\n                break;\n            }\n            visited.add(key);\n            \n            // Check bounds with very generous padding\n            const padding = 0.1; // Very large padding\n            if (currentLat < bounds.getSouth() - padding || currentLat > bounds.getNorth() + padding ||\n                currentLon < bounds.getWest() - padding || currentLon > bounds.getEast() + padding) {\n                break;\n            }\n            \n            // Get wind speed for this point\n            const windAtPoint = getWindAtPoint(currentLat, currentLon, data);\n            const speed = windAtPoint ? (windAtPoint.speed || 0) : 0;\n            \n            points.push([currentLat, currentLon, speed]);\n        }\n        \n        return points;\n    }\n    \n    // Animation function for pulsing effect\n    function animatePulse() {\n        if (!isAnimating) return;\n        \n        pulseOffset += 1.5; // Speed of pulse animation\n        if (pulseOffset >= 100) pulseOffset = 0;\n        \n        // Only redraw the canvas with new pulse position - NO data fetching, NO streamline regeneration\n        // Just redraw existing cached streamlines with updated pulse position\n        if (cachedStreamlines && radarMap && canvas && ctx) {\n            // Clear and redraw with new pulse position\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            drawStreamlines(cachedStreamlines);\n        }\n        \n        requestAnimationFrame(animatePulse);\n    }\n    \n    // Update canvas function - create smooth, continuous flow lines\n    const updateCanvas = (data = currentWindData) => {\n        const mapSize = radarMap.getSize();\n        const currentBounds = radarMap.getBounds();\n        \n        canvas.width = mapSize.x;\n        canvas.height = mapSize.y;\n        \n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \n        if (!data || data.length === 0) {\n            console.log('No wind data available');\n            return;\n        }\n        \n        // Only regenerate streamlines if we don't have cached ones or data changed\n        if (!cachedStreamlines) {\n            console.log('Generating streamlines with', data.length, 'wind data points');\n            \n            // Use fewer seed points but trace much longer lines\n            const seedGridSize = 8; // 8x8 = 64 seed points for better coverage\n            const latStep = (currentBounds.getNorth() - currentBounds.getSouth()) / (seedGridSize - 1);\n            const lonStep = (currentBounds.getEast() - currentBounds.getWest()) / (seedGridSize - 1);\n            \n            // Store all continuous streamlines\n            const allStreamlines = [];\n            \n            // Generate long, continuous streamlines from seed points\n            for (let i = 0; i < seedGridSize; i++) {\n                for (let j = 0; j < seedGridSize; j++) {\n                    const startLat = currentBounds.getSouth() + (i * latStep);\n                    const startLon = currentBounds.getWest() + (j * lonStep);\n                    \n                    // Trace forward and backward to create one long continuous streamline\n                    const forwardPoints = traceStreamline(startLat, startLon, true, data);\n                    const backwardPoints = traceStreamline(startLat, startLon, false, data).reverse();\n                    \n                    // Combine into one continuous streamline\n                    const completeStreamline = [...backwardPoints, [startLat, startLon, 0], ...forwardPoints];\n                    \n                    if (completeStreamline.length >= 10) { // Require at least 10 points for a visible line\n                        // Calculate average speed for coloring\n                        let totalSpeed = 0;\n                        let speedCount = 0;\n                        completeStreamline.forEach((point) => {\n                            if (point[2] !== undefined && point[2] >= 0) {\n                                totalSpeed += point[2];\n                                speedCount++;\n                            }\n                        });\n                        const avgSpeed = speedCount > 0 ? totalSpeed / speedCount : 0;\n                        \n                        allStreamlines.push({\n                            points: completeStreamline,\n                            avgSpeed: avgSpeed\n                        });\n                    }\n                }\n            }\n            \n            console.log('Generated', allStreamlines.length, 'streamlines');\n            \n            if (allStreamlines.length === 0) {\n                console.warn('No streamlines generated! Check traceStreamline function.');\n                // Draw a test line to verify canvas is working\n                ctx.beginPath();\n                ctx.moveTo(10, 10);\n                ctx.lineTo(100, 100);\n                ctx.strokeStyle = '#ff0000';\n                ctx.lineWidth = 3;\n                ctx.stroke();\n                console.log('Drew test line to verify canvas');\n                return;\n            }\n            \n            // Cache the streamlines\n            cachedStreamlines = allStreamlines;\n        }\n        \n        // Draw the cached streamlines\n        drawStreamlines(cachedStreamlines);\n    };\n    \n    // Function to draw streamlines (separated from generation for animation)\n    function drawStreamlines(allStreamlines) {\n        // Clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \n        // Draw all streamlines as smooth, continuous lines\n        allStreamlines.forEach((streamline, index) => {\n            const avgSpeed = streamline.avgSpeed;\n            const completeStreamline = streamline.points;\n            \n            // Color based on average wind speed\n            let color = '#7dd3fc'; // Light blue for light wind\n            if (avgSpeed > 30) color = '#f87171'; // Red for strong\n            else if (avgSpeed > 20) color = '#fb923c'; // Orange for moderate-strong\n            else if (avgSpeed > 15) color = '#fbbf24'; // Yellow for moderate\n            else if (avgSpeed > 10) color = '#60a5fa'; // Blue for light-moderate\n            \n            // Draw the continuous streamline with smooth curves\n            ctx.beginPath();\n            let isFirstPoint = true;\n            const pixelPoints = [];\n            \n            completeStreamline.forEach((point) => {\n                const [lat, lon] = point;\n                try {\n                    const pixelPoint = radarMap.latLngToContainerPoint([lat, lon]);\n                    pixelPoints.push({ x: pixelPoint.x, y: pixelPoint.y });\n                    \n                    if (isFirstPoint) {\n                        ctx.moveTo(pixelPoint.x, pixelPoint.y);\n                        isFirstPoint = false;\n                    } else {\n                        ctx.lineTo(pixelPoint.x, pixelPoint.y);\n                    }\n                } catch (e) {\n                    // Skip invalid points\n                    console.warn('Invalid point:', lat, lon, e);\n                }\n            });\n            \n            // Only draw if we have valid points\n            if (pixelPoints.length < 2) {\n                return;\n            }\n            \n            // Draw smooth, continuous line with pulsing animation\n            // Create gradient for pulsing effect\n            const gradient = ctx.createLinearGradient(\n                pixelPoints[0].x, pixelPoints[0].y,\n                pixelPoints[pixelPoints.length - 1].x,\n                pixelPoints[pixelPoints.length - 1].y\n            );\n            \n            // Calculate pulse position along the line (0 to 1)\n            const pulsePosition = (pulseOffset % 100) / 100;\n            const pulseWidth = 0.3; // Width of the pulse\n            \n            // Create gradient stops for pulsing effect\n            for (let i = 0; i <= 10; i++) {\n                const pos = i / 10;\n                let alpha = 0.3; // Base opacity\n                \n                // Create pulse effect moving along the line\n                const distFromPulse = Math.abs(pos - pulsePosition);\n                if (distFromPulse < pulseWidth) {\n                    // Bright pulse in the center, fading out\n                    const pulseIntensity = 1 - (distFromPulse / pulseWidth);\n                    alpha = 0.3 + (pulseIntensity * 0.55); // 0.3 to 0.85\n                }\n                \n                // Wrap around for continuous effect\n                const distFromPulseWrapped = Math.min(distFromPulse, 1 - distFromPulse);\n                if (distFromPulseWrapped < pulseWidth) {\n                    const pulseIntensity = 1 - (distFromPulseWrapped / pulseWidth);\n                    alpha = Math.max(alpha, 0.3 + (pulseIntensity * 0.55));\n                }\n                \n                gradient.addColorStop(pos, `rgba(${parseInt(color.slice(1, 3), 16)}, ${parseInt(color.slice(3, 5), 16)}, ${parseInt(color.slice(5, 7), 16)}, ${alpha})`);\n            }\n            \n            ctx.strokeStyle = gradient;\n            ctx.lineWidth = 3;\n            ctx.lineCap = 'round';\n            ctx.lineJoin = 'round';\n            ctx.stroke();\n            \n            // Also draw base line for better visibility\n            ctx.strokeStyle = color;\n            ctx.globalAlpha = 0.3;\n            ctx.lineWidth = 3.5;\n            ctx.stroke();\n            \n            // Debug: log first streamline only once\n            if (index === 0 && pulseOffset === 0) {\n                console.log('Drawing first streamline:', {\n                    points: completeStreamline.length,\n                    pixelPoints: pixelPoints.length,\n                    color: color,\n                    avgSpeed: avgSpeed\n                });\n            }\n            \n            // Draw minimal arrows - only a few per streamline\n            if (pixelPoints.length >= 20) {\n                const numArrows = Math.min(3, Math.floor(pixelPoints.length / 100)); // Max 3 arrows per line\n                const arrowSpacing = Math.floor(pixelPoints.length / (numArrows + 1));\n                const arrowSize = 6;\n                \n                for (let a = 1; a <= numArrows; a++) {\n                    const arrowIndex = a * arrowSpacing;\n                    if (arrowIndex >= pixelPoints.length - 1) break;\n                    \n                    const arrowPoint = pixelPoints[arrowIndex];\n                    const nextPoint = pixelPoints[Math.min(arrowIndex + 3, pixelPoints.length - 1)];\n                    \n                    // Calculate direction\n                    const dx = nextPoint.x - arrowPoint.x;\n                    const dy = nextPoint.y - arrowPoint.y;\n                    const angle = Math.atan2(dy, dx);\n                    \n                    // Draw small, subtle arrow\n                    ctx.save();\n                    ctx.translate(arrowPoint.x, arrowPoint.y);\n                    ctx.rotate(angle);\n                    \n                    ctx.beginPath();\n                    ctx.moveTo(0, 0);\n                    ctx.lineTo(-arrowSize, -arrowSize / 2.5);\n                    ctx.lineTo(-arrowSize * 0.7, 0);\n                    ctx.lineTo(-arrowSize, arrowSize / 2.5);\n                    ctx.closePath();\n                    \n                    ctx.fillStyle = color;\n                    ctx.globalAlpha = 0.85;\n                    ctx.fill();\n                    \n                    ctx.restore();\n                }\n            }\n        });\n    }\n    \n    // Create custom layer class\n    const WindCanvasLayer = L.Layer.extend({\n        onAdd: function(map) {\n            this._map = map;\n            this._canvas = canvas;\n            this._ctx = ctx;\n            this._windData = currentWindData;\n            map.getPanes().overlayPane.appendChild(canvas);\n            this._reset();\n            map.on('moveend', this._reset, this);\n            map.on('zoomend', this._reset, this);\n            updateCanvas(this._windData);\n            \n            // Start pulse animation\n            isAnimating = true;\n            animatePulse();\n        },\n        \n        onRemove: function(map) {\n            // Stop animation\n            isAnimating = false;\n            map.getPanes().overlayPane.removeChild(canvas);\n            map.off('moveend', this._reset, this);\n            map.off('zoomend', this._reset, this);\n        },\n        \n        _reset: function() {\n            const mapSize = this._map.getSize();\n            canvas.style.width = mapSize.x + 'px';\n            canvas.style.height = mapSize.y + 'px';\n            canvas.width = mapSize.x;\n            canvas.height = mapSize.y;\n            // Clear cache when map resets (zoom/pan) to regenerate streamlines for new view\n            cachedStreamlines = null;\n            this._redraw();\n        },\n        \n        _redraw: function() {\n            // Use stored wind data or current data\n            const dataToUse = this._windData || currentWindData || windGridData;\n            if (dataToUse) {\n                currentWindData = dataToUse;\n                // Clear cache to force regeneration with new map bounds\n                cachedStreamlines = null;\n                updateCanvas(dataToUse);\n            }\n        }\n    });\n    \n    windCanvasLayer = new WindCanvasLayer();\n    windCanvasLayer.addTo(radarMap);\n}\n\nfunction switchRadarLayer(layerType) {\n    // #region agent log\n    fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:2615',message:'switchRadarLayer called',data:{layerType},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});\n    // #endregion\n    currentRadarLayerType = layerType;\n    \n    // Update button styles\n    document.querySelectorAll('.radar-layer-btn').forEach(btn => {\n        btn.classList.remove('bg-blue-500/30', 'border-blue-400');\n        btn.classList.add('bg-white/20', 'border-transparent');\n    });\n    \n    const activeBtn = document.getElementById(`radarLayer${layerType.charAt(0).toUpperCase() + layerType.slice(1)}`);\n    if (activeBtn) {\n        activeBtn.classList.remove('bg-white/20', 'border-transparent');\n        activeBtn.classList.add('bg-blue-500/30', 'border-blue-400');\n    }\n    \n    // Update legend\n    initializeLegend();\n    \n    // Update map view size based on layer type\n    if (layerType === 'wind') {\n        // For wind: 10x10 miles - update Leaflet map\n        if (radarMap && currentLat && currentLon) {\n            const milesToDegrees = 0.144; // 10x10 miles\n            const halfSize = milesToDegrees / 2;\n            const bounds = [\n                [currentLat - halfSize, currentLon - halfSize],\n                [currentLat + halfSize, currentLon + halfSize]\n            ];\n            radarMap.fitBounds(bounds, { padding: [10, 10] });\n        }\n        \n        // Update the radar layer for wind (doesn't need radar frames)\n        updateRadarLayer(null);\n    } else if (layerType === 'precipitation') {\n        // Stop animation if switching away from precipitation\n        if (isRadarAnimating) {\n            toggleRadarAnimation();\n        }\n        \n        // Show time display for precipitation layer\n        const timeDisplay = document.getElementById('radarTimeDisplay');\n        if (timeDisplay) {\n            timeDisplay.classList.remove('hidden');\n        }\n        \n        // Show map container immediately so legend is visible\n        const mapContainer = document.getElementById('radarMap');\n        const iframeContainer = document.getElementById('radarIframeContainer');\n        // #region agent log\n        fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:2724',message:'switchRadarLayer precipitation - showing map container',data:{mapContainerExists:!!mapContainer,mapDisplayBefore:mapContainer?.style?.display,legendExists:!!document.getElementById('radarLegend'),legendInnerHTML:document.getElementById('radarLegend')?.innerHTML?.substring(0,50)},timestamp:Date.now(),sessionId:'debug-session',runId:'run2',hypothesisId:'G'})}).catch(()=>{});\n        // #endregion\n        if (mapContainer) mapContainer.style.display = 'block';\n        if (iframeContainer) iframeContainer.style.display = 'none';\n        // #region agent log\n        setTimeout(() => {\n            const legend = document.getElementById('radarLegend');\n            const computedStyle = window.getComputedStyle(legend);\n            const rect = legend.getBoundingClientRect();\n            fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:2727',message:'switchRadarLayer precipitation - after showing map',data:{mapDisplayAfter:mapContainer?.style?.display,legendExists:!!legend,legendInnerHTMLLength:legend?.innerHTML?.length,legendDisplay:computedStyle.display,legendVisibility:computedStyle.visibility,legendOpacity:computedStyle.opacity,legendWidth:rect.width,legendHeight:rect.height,parentDisplay:legend?.parentElement?.style?.display},timestamp:Date.now(),sessionId:'debug-session',runId:'run2',hypothesisId:'G'})}).catch(()=>{});\n        }, 50);\n        // #endregion\n        \n        // For precipitation: Update Leaflet map with NWS tiles\n        if (radarMap && currentLat && currentLon) {\n            const milesToDegrees = 1.44; // 100x100 miles\n            const halfSize = milesToDegrees / 2;\n            const bounds = [\n                [currentLat - halfSize, currentLon - halfSize],\n                [currentLat + halfSize, currentLon + halfSize]\n            ];\n            radarMap.fitBounds(bounds, { padding: [10, 10] });\n        }\n        \n        // Update the radar layer for precipitation\n        if (radarFrames.length > 0) {\n            const currentFrame = radarFrames[currentRadarFrame] || radarFrames[0];\n            // #region agent log\n            fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:2740',message:'switchRadarLayer precipitation - calling updateRadarLayer with frame',data:{hasFrame:!!currentFrame},timestamp:Date.now(),sessionId:'debug-session',runId:'run2',hypothesisId:'H'})}).catch(()=>{});\n            // #endregion\n            updateRadarLayer(currentFrame);\n        } else {\n            // #region agent log\n            fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:2743',message:'switchRadarLayer precipitation - calling fetchRadarData (no frames)',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run2',hypothesisId:'H'})}).catch(()=>{});\n            // #endregion\n            // Fetch radar data if we don't have frames\n            fetchNWSRadarData(currentLat, currentLon);\n        }\n        // #region agent log\n        setTimeout(() => {\n            const legend = document.getElementById('radarLegend');\n            const computedStyle = window.getComputedStyle(legend);\n            const rect = legend.getBoundingClientRect();\n            fetch('http://127.0.0.1:7244/ingest/3ad439b4-bfd8-472a-b938-f75691213087',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'app.js:2747',message:'switchRadarLayer precipitation - final legend state',data:{legendExists:!!legend,legendInnerHTMLLength:legend?.innerHTML?.length,legendDisplay:computedStyle.display,legendVisibility:computedStyle.visibility,legendWidth:rect.width,legendHeight:rect.height,isVisible:rect.width > 0 && rect.height > 0},timestamp:Date.now(),sessionId:'debug-session',runId:'run2',hypothesisId:'G'})}).catch(()=>{});\n        }, 200);\n        // #endregion\n    } else if (layerType === 'wind') {\n        // Hide time display for wind layer\n        const timeDisplay = document.getElementById('radarTimeDisplay');\n        if (timeDisplay) {\n            timeDisplay.classList.add('hidden');\n        }\n    }\n}\n\n// Precipitation navigation now uses the same controls as wind (radarZoomIn, etc.)\n// No separate setup needed - setupRadarNavigation() handles both\n\n// Radar layer buttons - wait for DOM to be ready\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Radar layer buttons\n    const precipBtn = document.getElementById('radarLayerPrecipitation');\n    const windBtn = document.getElementById('radarLayerWind');\n    \n    if (precipBtn) {\n        precipBtn.addEventListener('click', () => switchRadarLayer('precipitation'));\n    }\n    if (windBtn) {\n        windBtn.addEventListener('click', () => switchRadarLayer('wind'));\n    }\n    \n});\n\n";
const FAVICON_CONTENT = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\" width=\"512\" height=\"512\">\n  <defs>\n    <!-- Dark gray gradient background -->\n    <linearGradient id=\"bgGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n      <stop offset=\"0%\" style=\"stop-color:#374151;stop-opacity:1\" />\n      <stop offset=\"100%\" style=\"stop-color:#1f2937;stop-opacity:1\" />\n    </linearGradient>\n    <!-- Gradient for cloud -->\n    <linearGradient id=\"cloudGradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n      <stop offset=\"0%\" style=\"stop-color:#93c5fd;stop-opacity:1\" />\n      <stop offset=\"100%\" style=\"stop-color:#60a5fa;stop-opacity:1\" />\n    </linearGradient>\n    <!-- Gradient for sun -->\n    <radialGradient id=\"sunGradient\" cx=\"50%\" cy=\"50%\">\n      <stop offset=\"0%\" style=\"stop-color:#fef3c7;stop-opacity:1\" />\n      <stop offset=\"100%\" style=\"stop-color:#fbbf24;stop-opacity:1\" />\n    </radialGradient>\n    <!-- Shadow filter -->\n    <filter id=\"shadow\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\n      <feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"4\"/>\n      <feOffset dx=\"2\" dy=\"2\" result=\"offsetblur\"/>\n      <feComponentTransfer>\n        <feFuncA type=\"linear\" slope=\"0.3\"/>\n      </feComponentTransfer>\n      <feMerge>\n        <feMergeNode/>\n        <feMergeNode in=\"SourceGraphic\"/>\n      </feMerge>\n    </filter>\n  </defs>\n  \n  <!-- Dark gray gradient background -->\n  <rect width=\"512\" height=\"512\" fill=\"url(#bgGradient)\"/>\n  \n  <!-- Cloud with gradient and shadow - scaled and centered -->\n  <g transform=\"translate(80, 200) scale(0.7)\">\n    <path fill=\"url(#cloudGradient)\" filter=\"url(#shadow)\" d=\"M416 128c-.6 0-1.1.2-1.6.2 1.1-5.2 1.6-10.6 1.6-16 0-44.2-35.8-80-80-80-24.6 0-46.3 11.3-61 28.8C256.4 24.8 219.3 0 176 0 114 0 64 50 64 112c0 7.1.7 14.1 2.1 20.8C27.8 145.4 0 181.5 0 224c0 53 43 96 96 96h320c53 0 96-43 96-96s-43-96-96-96z\"/>\n  </g>\n  \n  <!-- Sun with gradient and shadow - positioned just above the cloud, slightly to the right -->\n  <g transform=\"translate(320, 160)\">\n    <g filter=\"url(#shadow)\">\n      <!-- Sun rays (8 rays evenly spaced) -->\n      <line stroke=\"#fbbf24\" stroke-width=\"10\" stroke-linecap=\"round\" x1=\"0\" y1=\"-100\" x2=\"0\" y2=\"-80\"/>\n      <line stroke=\"#fbbf24\" stroke-width=\"10\" stroke-linecap=\"round\" x1=\"0\" y1=\"80\" x2=\"0\" y2=\"100\"/>\n      <line stroke=\"#fbbf24\" stroke-width=\"10\" stroke-linecap=\"round\" x1=\"-100\" y1=\"0\" x2=\"-80\" y2=\"0\"/>\n      <line stroke=\"#fbbf24\" stroke-width=\"10\" stroke-linecap=\"round\" x1=\"80\" y1=\"0\" x2=\"100\" y2=\"0\"/>\n      <line stroke=\"#fbbf24\" stroke-width=\"10\" stroke-linecap=\"round\" x1=\"-70.71\" y1=\"-70.71\" x2=\"-56.57\" y2=\"-56.57\"/>\n      <line stroke=\"#fbbf24\" stroke-width=\"10\" stroke-linecap=\"round\" x1=\"56.57\" y1=\"56.57\" x2=\"70.71\" y2=\"70.71\"/>\n      <line stroke=\"#fbbf24\" stroke-width=\"10\" stroke-linecap=\"round\" x1=\"70.71\" y1=\"-70.71\" x2=\"56.57\" y2=\"-56.57\"/>\n      <line stroke=\"#fbbf24\" stroke-width=\"10\" stroke-linecap=\"round\" x1=\"-56.57\" y1=\"56.57\" x2=\"-70.71\" y2=\"70.71\"/>\n      <!-- Sun circle -->\n      <circle fill=\"url(#sunGradient)\" cx=\"0\" cy=\"0\" r=\"40\"/>\n    </g>\n  </g>\n</svg>\n";
const APPLE_TOUCH_ICON_BASE64 = "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";

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // Serve the HTML page
    if (url.pathname === '/' || url.pathname === '/index.html') {
      return new Response(HTML_CONTENT, {
        headers: {
          'Content-Type': 'text/html;charset=UTF-8',
        },
      });
    }
    
    // Serve the JavaScript file
    if (url.pathname === '/app.js') {
      return new Response(JS_CONTENT, {
        headers: {
          'Content-Type': 'application/javascript',
        },
      });
    }
    
    // Serve the favicon
    if (url.pathname === '/favicon.svg') {
      return new Response(FAVICON_CONTENT, {
        headers: {
          'Content-Type': 'image/svg+xml',
          'Cache-Control': 'public, max-age=31536000', // Cache for 1 year
        },
      });
    }
    
    // Serve the Apple touch icon (PNG for iOS)
    if (url.pathname === '/apple-touch-icon.png') {
      const pngBuffer = Uint8Array.from(atob(APPLE_TOUCH_ICON_BASE64), c => c.charCodeAt(0));
      return new Response(pngBuffer, {
        headers: {
          'Content-Type': 'image/png',
          'Cache-Control': 'public, max-age=31536000', // Cache for 1 year
        },
      });
    }
    
    // Proxy API requests to avoid CORS issues
    if (url.pathname.startsWith('/api/')) {
      const apiPath = url.pathname.replace('/api/', '');
      let targetUrl;
      
      // Geocoding API uses a different base URL
      if (apiPath.startsWith('geocoding')) {
        // Convert /api/geocoding?name=... to geocoding-api.open-meteo.com/v1/search?name=...
        const searchParams = url.search;
        targetUrl = `https://geocoding-api.open-meteo.com/v1/search${searchParams}`;
      } else if (apiPath.startsWith('reverse')) {
        // Reverse geocoding using BigDataCloud (free, no API key needed)
        // Extract lat and lon from query params
        const lat = url.searchParams.get('lat');
        const lon = url.searchParams.get('lon');
        if (lat && lon) {
          targetUrl = `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}&localityLanguage=en`;
        } else {
          return new Response(JSON.stringify({ error: true, reason: 'Missing lat or lon parameters' }), {
            status: 400,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
          });
        }
      } else if (apiPath.startsWith('alerts')) {
        // National Weather Service alerts API (US only)
        // Remove /api/ prefix and construct the full NWS URL
        const nwsPath = apiPath; // apiPath is already "alerts/active/zone/..." or "alerts/active"
        targetUrl = `https://api.weather.gov/${nwsPath}${url.search}`;
      } else if (apiPath.startsWith('nws-points')) {
        // NWS points API to get forecast zones
        const pathParts = apiPath.split('/');
        if (pathParts.length > 1) {
          targetUrl = `https://api.weather.gov/points/${pathParts.slice(1).join('/')}`;
        } else {
          targetUrl = `https://api.weather.gov/points${url.search}`;
        }
      } else if (apiPath.startsWith('nws-wms')) {
        // Proxy for NWS WMS service to handle CORS
        // Extract WMS parameters from query string
        const wmsParams = new URLSearchParams(url.search);
        // #region agent log
        const logData = {originalQuery:url.search,allParams:Object.fromEntries(wmsParams.entries()),hasTime:wmsParams.has('time'),timeValue:wmsParams.get('time')};
        // #endregion
        // Build the WMS GetMap request URL
        // Use RIDGE2 WMS endpoint - official NWS radar service
        const wmsBaseUrl = 'https://opengeo.ncep.noaa.gov/geoserver/ows';
        // Preserve all existing parameters (including time if present)
        wmsParams.set('service', 'WMS');
        wmsParams.set('request', 'GetMap');
        if (!wmsParams.has('version')) {
          wmsParams.set('version', '1.3.0');
        }
        if (!wmsParams.has('styles')) {
          wmsParams.set('styles', '');
        }
        targetUrl = `${wmsBaseUrl}?${wmsParams.toString()}`;
        // #region agent log
        const finalLogData = {targetUrl:targetUrl,finalParams:Object.fromEntries(wmsParams.entries()),hasTimeFinal:wmsParams.has('time'),timeValueFinal:wmsParams.get('time')};
        // #endregion
      } else {
        // Weather API uses the standard base URL
        targetUrl = `https://api.open-meteo.com/v1/${apiPath}${url.search}`;
      }
      
      try {
        let fetchOptions = {};
        // Add user agent for NWS (required by their usage policy)
        if (apiPath.startsWith('alerts') || apiPath.startsWith('nws-points') || apiPath.startsWith('nws-wms')) {
          const headers = new Headers();
          headers.set('User-Agent', 'WeatherApp/1.0 (contact@example.com)');
          fetchOptions = { headers };
        }
        
        // Special handling for NWS WMS - proxy images with CORS headers
        if (apiPath.startsWith('nws-wms')) {
          try {
            // #region agent log
            // Log the full request URL and all parameters for debugging
            const requestParams = {
              targetUrl: targetUrl,
              method: 'GET',
              hasTime: wmsParams.has('time'),
              timeValue: wmsParams.get('time'),
              allParams: Object.fromEntries(wmsParams.entries()),
              bbox: wmsParams.get('BBOX') || wmsParams.get('bbox'),
              crs: wmsParams.get('CRS') || wmsParams.get('crs'),
              layers: wmsParams.get('LAYERS') || wmsParams.get('layers')
            };
            console.error('NWS_WMS_PROXY_REQUEST', JSON.stringify(requestParams));
            // #endregion
            const response = await fetch(targetUrl, fetchOptions);
            
            // Get content type early
            const responseContentType = response.headers.get('Content-Type') || 'unknown';
            const responseIsImage = responseContentType.startsWith('image/');
            const responseIsXML = responseContentType.includes('xml') || responseContentType.includes('html');
            
            // #region agent log
            console.error('NWS_WMS_PROXY_RESPONSE', JSON.stringify({status:response.status,statusText:response.statusText,ok:response.ok,contentType:responseContentType,isImage:responseIsImage,isXML:responseIsXML,targetUrl:targetUrl}));
            // #endregion
            
            if (!response.ok) {
              // #region agent log
              const errorText = await response.text().catch(() => '');
              console.error('NWS_WMS_PROXY_ERROR', JSON.stringify({status:response.status,statusText:response.statusText,errorText:errorText.substring(0,200),targetUrl:targetUrl}));
              // #endregion
              // Return a transparent PNG for errors
              const transparentPng256 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
              return new Response(Uint8Array.from(atob(transparentPng256), c => c.charCodeAt(0)), {
                status: 200,
                headers: {
                  'Content-Type': 'image/png',
                  'Access-Control-Allow-Origin': '*',
                  'Cache-Control': 'public, max-age=300',
                },
              });
            }
            
            // Get the response data
            const responseData = await response.arrayBuffer();
            
            // Check if response is actually a valid PNG (starts with PNG signature: 89 50 4E 47)
            const pngFirstBytes = Array.from(new Uint8Array(responseData.slice(0, 8)));
            const pngIsValid = pngFirstBytes[0] === 0x89 && pngFirstBytes[1] === 0x50 && pngFirstBytes[2] === 0x4E && pngFirstBytes[3] === 0x47;
            
            // #region agent log
            console.error('NWS_WMS_PROXY_DATA', JSON.stringify({dataSize:responseData.byteLength,contentType:responseContentType,isImage:responseIsImage,isPNG:pngIsValid,firstBytes:pngFirstBytes,targetUrl:targetUrl}));
            // #endregion
            
            // If it's not an image (likely XML error), return transparent PNG
            if (!responseIsImage) {
              // #region agent log
              const textData = new TextDecoder().decode(responseData.slice(0, 500));
              console.error('NWS_WMS_PROXY_NOT_IMAGE', JSON.stringify({contentType:responseContentType,textData:textData,targetUrl:targetUrl}));
              // #endregion
              const transparentPng256 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
              return new Response(Uint8Array.from(atob(transparentPng256), c => c.charCodeAt(0)), {
                status: 200,
                headers: {
                  'Content-Type': 'image/png',
                  'Access-Control-Allow-Origin': '*',
                  'Cache-Control': 'public, max-age=60',
                },
              });
            }
            
            // If it's not a valid PNG (might be error image or XML), check and log
            if (!pngIsValid && responseData.byteLength > 0) {
              // #region agent log
              const textData = new TextDecoder().decode(responseData.slice(0, 500));
              console.error('NWS_WMS_PROXY_INVALID_PNG', JSON.stringify({contentType:responseContentType,textData:textData,dataSize:responseData.byteLength,targetUrl:targetUrl}));
              // #endregion
              // Return transparent PNG for invalid images
              const transparentPng256 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
              return new Response(Uint8Array.from(atob(transparentPng256), c => c.charCodeAt(0)), {
                status: 200,
                headers: {
                  'Content-Type': 'image/png',
                  'Access-Control-Allow-Origin': '*',
                  'Cache-Control': 'public, max-age=60',
                },
              });
            }
            
            // Only log small PNGs but don't block them - valid tiles can be small
            // Only block if it's exactly our 68-byte error PNG
            const ourErrorPngSize = 68; // Size of our transparent error PNG
            if (pngIsValid && responseData.byteLength === ourErrorPngSize) {
              // #region agent log
              console.error('NWS_WMS_PROXY_SUSPECTED_ERROR_PNG', JSON.stringify({dataSize:responseData.byteLength,isPNG:pngIsValid,firstBytes:pngFirstBytes,targetUrl:targetUrl}));
              // #endregion
              // This might be our own error PNG being returned - investigate but still pass it through
            } else if (pngIsValid && responseData.byteLength < 200) {
              // Log small but potentially valid PNGs (might be empty/transparent tiles)
              // #region agent log
              console.error('NWS_WMS_PROXY_SMALL_PNG', JSON.stringify({dataSize:responseData.byteLength,isPNG:pngIsValid,firstBytes:pngFirstBytes,targetUrl:targetUrl}));
              // #endregion
            }
            
            // #region agent log
            console.error('NWS_WMS_PROXY_SUCCESS', JSON.stringify({imageDataSize:responseData.byteLength,isPNG:pngIsValid,targetUrl:targetUrl}));
            // #endregion
            
            // Return the image with CORS headers - pass through all valid PNGs regardless of size
            return new Response(responseData, {
              headers: {
                'Content-Type': responseContentType || 'image/png',
                'Access-Control-Allow-Origin': '*',
                'Cache-Control': 'public, max-age=300', // Cache for 5 minutes
              },
            });
          } catch (error) {
            // #region agent log
            console.error('NWS_WMS_PROXY_FETCH_ERROR', JSON.stringify({errorMessage:error.message,errorStack:error.stack,targetUrl:targetUrl}));
            // #endregion
            console.error('NWS WMS proxy error:', error, 'for URL:', targetUrl);
            // Return transparent PNG on error
            const transparentPng256 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
            return new Response(Uint8Array.from(atob(transparentPng256), c => c.charCodeAt(0)), {
              status: 200,
              headers: {
                'Content-Type': 'image/png',
                'Access-Control-Allow-Origin': '*',
                'Cache-Control': 'public, max-age=60',
              },
            });
          }
        }
        
        if (apiPath.startsWith('reverse')) {
          // Special handling for reverse geocoding (BigDataCloud)
          try {
            const response = await fetch(targetUrl, fetchOptions);
            
            if (!response.ok) {
              const errorText = await response.text();
              console.error(`Reverse geocoding API error (${response.status}):`, errorText.substring(0, 200));
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            // BigDataCloud returns the data directly, no error field to check
            // Transform to match expected format
            const transformedData = {
              address: {
                city: data.city || data.locality,
                town: data.town,
                village: data.village,
                municipality: data.municipality,
                county: data.county,
                state: data.principalSubdivision,
                state_district: data.principalSubdivision,
                country: data.countryName,
              },
              display_name: data.displayName || `${data.city || data.locality || ''}, ${data.principalSubdivision || ''}`.trim(),
            };
            
            return new Response(JSON.stringify(transformedData), {
              headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
              },
            });
          } catch (fetchError) {
            // Re-throw to be caught by outer catch block
            throw fetchError;
          }
        } else {
          // Standard handling for other APIs (forecast, geocoding, etc.)
          try {
            // Create cache key from the full request URL
            const cacheKey = new Request(targetUrl);
            
            // Try to get from cache first (only for forecast and geocoding)
            if (apiPath.startsWith('forecast') || apiPath.startsWith('geocoding')) {
              const cachedResponse = await caches.default.match(cacheKey);
              if (cachedResponse) {
                // Clone the cached response and add CORS headers
                const cachedData = await cachedResponse.json();
                return new Response(JSON.stringify(cachedData), {
                  headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*',
                    'X-Cache': 'HIT',
                  },
                });
              }
            }
            
            // Add timeout for long-running requests (30 seconds)
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000);
            
            if (!fetchOptions) {
              fetchOptions = {};
            }
            fetchOptions.signal = controller.signal;
            
            // Add User-Agent header for Open-Meteo to help with rate limiting
            if (apiPath.startsWith('forecast') || apiPath.startsWith('geocoding')) {
              if (!fetchOptions.headers) {
                fetchOptions.headers = new Headers();
              }
              // Use a descriptive User-Agent to help Open-Meteo identify the app
              fetchOptions.headers.set('User-Agent', 'WeatherApp/1.0 (https://weather-app.jackanglim3.workers.dev)');
            }
            
            // Retry logic for rate limits (max 2 retries)
            let response;
            let retries = 0;
            const maxRetries = 2;
            
            while (retries <= maxRetries) {
              response = await fetch(targetUrl, fetchOptions);
              
              // If we get a 429, check for Retry-After header and wait accordingly
              if (response.status === 429 && retries < maxRetries) {
                const retryAfter = response.headers.get('Retry-After');
                const waitTime = retryAfter 
                  ? parseInt(retryAfter, 10) * 1000 
                  : Math.pow(2, retries) * 1000; // 1s, 2s, 4s
                console.log(`Rate limited, retrying in ${waitTime}ms... (attempt ${retries + 1}/${maxRetries})`);
                await new Promise(resolve => setTimeout(resolve, Math.min(waitTime, 10000))); // Max 10s wait
                retries++;
                continue;
              }
              
              break; // Success or non-retryable error
            }
            
            clearTimeout(timeoutId);
            
            // Handle rate limiting (429) after retries exhausted
            if (response.status === 429) {
              // Check for Retry-After header to provide specific wait time
              const retryAfter = response.headers.get('Retry-After');
              let waitMessage = 'Rate limit exceeded. ';
              if (retryAfter) {
                const waitSeconds = parseInt(retryAfter, 10);
                const waitMinutes = Math.ceil(waitSeconds / 60);
                waitMessage += `Please wait ${waitMinutes} minute${waitMinutes > 1 ? 's' : ''} and try again.`;
              } else {
                waitMessage += 'Please wait 1-2 minutes and try again.';
              }
              
              return new Response(JSON.stringify({ 
                error: true, 
                reason: waitMessage
              }), {
                status: 429,
                headers: {
                  'Content-Type': 'application/json',
                  'Access-Control-Allow-Origin': '*',
                },
              });
            }
            
            if (!response.ok) {
              const errorText = await response.text();
              console.error(`API error (${response.status}) for ${targetUrl}:`, errorText.substring(0, 200));
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            // Try to parse as JSON
            let data;
            let text;
            try {
              text = await response.text();
              // Check if response is empty
              if (!text || text.trim().length === 0) {
                throw new Error('Empty response from API');
              }
              data = JSON.parse(text);
            } catch (parseError) {
              const contentType = response.headers.get('content-type');
              console.error('Failed to parse JSON response. Content-Type:', contentType, 'Response preview:', text?.substring(0, 200));
              
              // If we got a 429 but it's not JSON, return a proper error
              if (response.status === 429) {
                return new Response(JSON.stringify({ 
                  error: true, 
                  reason: 'Rate limit exceeded. Please try again in a few moments.' 
                }), {
                  status: 429,
                  headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*',
                  },
                });
              }
              
              throw new Error(`Invalid response format: ${parseError.message}`);
            }
            
            // Cache successful responses (only for forecast and geocoding)
            if (apiPath.startsWith('forecast') || apiPath.startsWith('geocoding')) {
              // Determine cache duration based on API type
              const cacheSeconds = apiPath.startsWith('forecast') ? 600 : 3600; // 10 min for forecast, 1 hour for geocoding
              
              // Create a response with cache headers
              const cacheResponse = new Response(JSON.stringify(data), {
                headers: {
                  'Content-Type': 'application/json',
                  'Cache-Control': `public, max-age=${cacheSeconds}`,
                },
              });
              
              // Store in cache
              ctx.waitUntil(caches.default.put(cacheKey, cacheResponse.clone()));
            }
            
            return new Response(JSON.stringify(data), {
              headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
                'X-Cache': 'MISS',
              },
            });
          } catch (fetchError) {
            if (fetchError.name === 'AbortError') {
              console.error('Request timeout for', targetUrl);
              throw new Error('Request timeout');
            }
            console.error('Fetch error for', targetUrl, ':', fetchError.message);
            throw fetchError;
          }
        }
      } catch (error) {
        console.error('API proxy error:', error);
        return new Response(JSON.stringify({ error: true, reason: error.message }), {
          status: 500,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
        });
      }
    }
    
    return new Response('Not Found', { status: 404 });
  },
};
