const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { execSync } = require('child_process');

// Convert SVG to PNG for iOS (if convert-favicon.js exists)
try {
  if (fs.existsSync(path.join(__dirname, 'convert-favicon.js'))) {
    execSync('node convert-favicon.js', { stdio: 'inherit' });
  }
} catch (error) {
  console.warn('Warning: Could not convert favicon to PNG:', error.message);
  console.warn('Continuing with build...');
}

// Read the HTML, JS, and favicon files
let htmlContent = fs.readFileSync(path.join(__dirname, 'public', 'index.html'), 'utf8');
const jsContent = fs.readFileSync(path.join(__dirname, 'public', 'app.js'), 'utf8');
const faviconContent = fs.readFileSync(path.join(__dirname, 'public', 'favicon.svg'), 'utf8');
const appleTouchIconContent = fs.readFileSync(path.join(__dirname, 'public', 'apple-touch-icon.png'));

// Generate a hash of the SVG content for cache-busting
// This ensures the icon URL changes automatically when the icon is modified
const svgHash = crypto.createHash('md5').update(faviconContent).digest('hex').substring(0, 8);

// Update the HTML to include the version parameter in the apple-touch-icon URL
htmlContent = htmlContent.replace(
  /href="\/apple-touch-icon\.png"/,
  `href="/apple-touch-icon.png?v=${svgHash}"`
);

// Convert PNG to base64 for embedding
const appleTouchIconBase64 = appleTouchIconContent.toString('base64');

// Create the worker file with embedded content
const workerContent = `// This file is auto-generated by build.js
const HTML_CONTENT = ${JSON.stringify(htmlContent)};
const JS_CONTENT = ${JSON.stringify(jsContent)};
const FAVICON_CONTENT = ${JSON.stringify(faviconContent)};
const APPLE_TOUCH_ICON_BASE64 = ${JSON.stringify(appleTouchIconBase64)};

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // Serve the HTML page
    if (url.pathname === '/' || url.pathname === '/index.html') {
      return new Response(HTML_CONTENT, {
        headers: {
          'Content-Type': 'text/html;charset=UTF-8',
        },
      });
    }
    
    // Serve the JavaScript file
    if (url.pathname === '/app.js') {
      return new Response(JS_CONTENT, {
        headers: {
          'Content-Type': 'application/javascript',
        },
      });
    }
    
    // Serve the favicon
    if (url.pathname === '/favicon.svg') {
      return new Response(FAVICON_CONTENT, {
        headers: {
          'Content-Type': 'image/svg+xml',
          'Cache-Control': 'public, max-age=31536000', // Cache for 1 year
        },
      });
    }
    
    // Serve the Apple touch icon (PNG for iOS)
    if (url.pathname === '/apple-touch-icon.png') {
      const pngBuffer = Uint8Array.from(atob(APPLE_TOUCH_ICON_BASE64), c => c.charCodeAt(0));
      return new Response(pngBuffer, {
        headers: {
          'Content-Type': 'image/png',
          'Cache-Control': 'public, max-age=31536000', // Cache for 1 year
        },
      });
    }
    
    // Proxy API requests to avoid CORS issues
    if (url.pathname.startsWith('/api/')) {
      const apiPath = url.pathname.replace('/api/', '');
      let targetUrl;
      
      // Geocoding API uses a different base URL
      if (apiPath.startsWith('geocoding')) {
        // Convert /api/geocoding?name=... to geocoding-api.open-meteo.com/v1/search?name=...
        const searchParams = url.search;
        targetUrl = \`https://geocoding-api.open-meteo.com/v1/search\${searchParams}\`;
      } else if (apiPath.startsWith('reverse')) {
        // Reverse geocoding using BigDataCloud (free, no API key needed)
        // Extract lat and lon from query params
        const lat = url.searchParams.get('lat');
        const lon = url.searchParams.get('lon');
        if (lat && lon) {
          targetUrl = \`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=\${encodeURIComponent(lat)}&longitude=\${encodeURIComponent(lon)}&localityLanguage=en\`;
        } else {
          return new Response(JSON.stringify({ error: true, reason: 'Missing lat or lon parameters' }), {
            status: 400,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
          });
        }
      } else if (apiPath.startsWith('alerts')) {
        // National Weather Service alerts API (US only)
        // Remove /api/ prefix and construct the full NWS URL
        const nwsPath = apiPath; // apiPath is already "alerts/active/zone/..." or "alerts/active"
        targetUrl = \`https://api.weather.gov/\${nwsPath}\${url.search}\`;
      } else if (apiPath.startsWith('nws-points')) {
        // NWS points API to get forecast zones
        const pathParts = apiPath.split('/');
        if (pathParts.length > 1) {
          targetUrl = \`https://api.weather.gov/points/\${pathParts.slice(1).join('/')}\`;
        } else {
          targetUrl = \`https://api.weather.gov/points\${url.search}\`;
        }
      } else if (apiPath.startsWith('nws-wms')) {
        // Proxy for NWS WMS service to handle CORS
        // Extract WMS parameters from query string
        const wmsParams = new URLSearchParams(url.search);
        // #region agent log
        const logData = {originalQuery:url.search,allParams:Object.fromEntries(wmsParams.entries()),hasTime:wmsParams.has('time'),timeValue:wmsParams.get('time')};
        // #endregion
        // Build the WMS GetMap request URL
        // Use RIDGE2 WMS endpoint - official NWS radar service
        const wmsBaseUrl = 'https://opengeo.ncep.noaa.gov/geoserver/ows';
        // Preserve all existing parameters (including time if present)
        wmsParams.set('service', 'WMS');
        wmsParams.set('request', 'GetMap');
        if (!wmsParams.has('version')) {
          wmsParams.set('version', '1.3.0');
        }
        if (!wmsParams.has('styles')) {
          wmsParams.set('styles', '');
        }
        targetUrl = \`\${wmsBaseUrl}?\${wmsParams.toString()}\`;
        // #region agent log
        const finalLogData = {targetUrl:targetUrl,finalParams:Object.fromEntries(wmsParams.entries()),hasTimeFinal:wmsParams.has('time'),timeValueFinal:wmsParams.get('time')};
        // #endregion
      } else {
        // Weather API uses the standard base URL
        targetUrl = \`https://api.open-meteo.com/v1/\${apiPath}\${url.search}\`;
      }
      
      try {
        let fetchOptions = {};
        // Add user agent for NWS (required by their usage policy)
        if (apiPath.startsWith('alerts') || apiPath.startsWith('nws-points') || apiPath.startsWith('nws-wms')) {
          const headers = new Headers();
          headers.set('User-Agent', 'WeatherApp/1.0 (contact@example.com)');
          fetchOptions = { headers };
        }
        
        // Special handling for NWS WMS - proxy images with CORS headers
        if (apiPath.startsWith('nws-wms')) {
          try {
            // #region agent log
            // Log the full request URL and all parameters for debugging
            const requestParams = {
              targetUrl: targetUrl,
              method: 'GET',
              hasTime: wmsParams.has('time'),
              timeValue: wmsParams.get('time'),
              allParams: Object.fromEntries(wmsParams.entries()),
              bbox: wmsParams.get('BBOX') || wmsParams.get('bbox'),
              crs: wmsParams.get('CRS') || wmsParams.get('crs'),
              layers: wmsParams.get('LAYERS') || wmsParams.get('layers')
            };
            console.error('NWS_WMS_PROXY_REQUEST', JSON.stringify(requestParams));
            // #endregion
            const response = await fetch(targetUrl, fetchOptions);
            
            // Get content type early
            const responseContentType = response.headers.get('Content-Type') || 'unknown';
            const responseIsImage = responseContentType.startsWith('image/');
            const responseIsXML = responseContentType.includes('xml') || responseContentType.includes('html');
            
            // #region agent log
            console.error('NWS_WMS_PROXY_RESPONSE', JSON.stringify({status:response.status,statusText:response.statusText,ok:response.ok,contentType:responseContentType,isImage:responseIsImage,isXML:responseIsXML,targetUrl:targetUrl}));
            // #endregion
            
            if (!response.ok) {
              // #region agent log
              const errorText = await response.text().catch(() => '');
              console.error('NWS_WMS_PROXY_ERROR', JSON.stringify({status:response.status,statusText:response.statusText,errorText:errorText.substring(0,200),targetUrl:targetUrl}));
              // #endregion
              // Return a transparent PNG for errors
              const transparentPng256 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
              return new Response(Uint8Array.from(atob(transparentPng256), c => c.charCodeAt(0)), {
                status: 200,
                headers: {
                  'Content-Type': 'image/png',
                  'Access-Control-Allow-Origin': '*',
                  'Cache-Control': 'public, max-age=300',
                },
              });
            }
            
            // Get the response data
            const responseData = await response.arrayBuffer();
            
            // Check if response is actually a valid PNG (starts with PNG signature: 89 50 4E 47)
            const pngFirstBytes = Array.from(new Uint8Array(responseData.slice(0, 8)));
            const pngIsValid = pngFirstBytes[0] === 0x89 && pngFirstBytes[1] === 0x50 && pngFirstBytes[2] === 0x4E && pngFirstBytes[3] === 0x47;
            
            // #region agent log
            console.error('NWS_WMS_PROXY_DATA', JSON.stringify({dataSize:responseData.byteLength,contentType:responseContentType,isImage:responseIsImage,isPNG:pngIsValid,firstBytes:pngFirstBytes,targetUrl:targetUrl}));
            // #endregion
            
            // If it's not an image (likely XML error), return transparent PNG
            if (!responseIsImage) {
              // #region agent log
              const textData = new TextDecoder().decode(responseData.slice(0, 500));
              console.error('NWS_WMS_PROXY_NOT_IMAGE', JSON.stringify({contentType:responseContentType,textData:textData,targetUrl:targetUrl}));
              // #endregion
              const transparentPng256 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
              return new Response(Uint8Array.from(atob(transparentPng256), c => c.charCodeAt(0)), {
                status: 200,
                headers: {
                  'Content-Type': 'image/png',
                  'Access-Control-Allow-Origin': '*',
                  'Cache-Control': 'public, max-age=60',
                },
              });
            }
            
            // If it's not a valid PNG (might be error image or XML), check and log
            if (!pngIsValid && responseData.byteLength > 0) {
              // #region agent log
              const textData = new TextDecoder().decode(responseData.slice(0, 500));
              console.error('NWS_WMS_PROXY_INVALID_PNG', JSON.stringify({contentType:responseContentType,textData:textData,dataSize:responseData.byteLength,targetUrl:targetUrl}));
              // #endregion
              // Return transparent PNG for invalid images
              const transparentPng256 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
              return new Response(Uint8Array.from(atob(transparentPng256), c => c.charCodeAt(0)), {
                status: 200,
                headers: {
                  'Content-Type': 'image/png',
                  'Access-Control-Allow-Origin': '*',
                  'Cache-Control': 'public, max-age=60',
                },
              });
            }
            
            // Only log small PNGs but don't block them - valid tiles can be small
            // Only block if it's exactly our 68-byte error PNG
            const ourErrorPngSize = 68; // Size of our transparent error PNG
            if (pngIsValid && responseData.byteLength === ourErrorPngSize) {
              // #region agent log
              console.error('NWS_WMS_PROXY_SUSPECTED_ERROR_PNG', JSON.stringify({dataSize:responseData.byteLength,isPNG:pngIsValid,firstBytes:pngFirstBytes,targetUrl:targetUrl}));
              // #endregion
              // This might be our own error PNG being returned - investigate but still pass it through
            } else if (pngIsValid && responseData.byteLength < 200) {
              // Log small but potentially valid PNGs (might be empty/transparent tiles)
              // #region agent log
              console.error('NWS_WMS_PROXY_SMALL_PNG', JSON.stringify({dataSize:responseData.byteLength,isPNG:pngIsValid,firstBytes:pngFirstBytes,targetUrl:targetUrl}));
              // #endregion
            }
            
            // #region agent log
            console.error('NWS_WMS_PROXY_SUCCESS', JSON.stringify({imageDataSize:responseData.byteLength,isPNG:pngIsValid,targetUrl:targetUrl}));
            // #endregion
            
            // Return the image with CORS headers - pass through all valid PNGs regardless of size
            return new Response(responseData, {
              headers: {
                'Content-Type': responseContentType || 'image/png',
                'Access-Control-Allow-Origin': '*',
                'Cache-Control': 'public, max-age=300', // Cache for 5 minutes
              },
            });
          } catch (error) {
            // #region agent log
            console.error('NWS_WMS_PROXY_FETCH_ERROR', JSON.stringify({errorMessage:error.message,errorStack:error.stack,targetUrl:targetUrl}));
            // #endregion
            console.error('NWS WMS proxy error:', error, 'for URL:', targetUrl);
            // Return transparent PNG on error
            const transparentPng256 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
            return new Response(Uint8Array.from(atob(transparentPng256), c => c.charCodeAt(0)), {
              status: 200,
              headers: {
                'Content-Type': 'image/png',
                'Access-Control-Allow-Origin': '*',
                'Cache-Control': 'public, max-age=60',
              },
            });
          }
        }
        
        if (apiPath.startsWith('reverse')) {
          // Special handling for reverse geocoding (BigDataCloud)
          try {
            const response = await fetch(targetUrl, fetchOptions);
            
            if (!response.ok) {
              const errorText = await response.text();
              console.error(\`Reverse geocoding API error (\${response.status}):\`, errorText.substring(0, 200));
              throw new Error(\`HTTP error! status: \${response.status}\`);
            }
            
            const data = await response.json();
            
            // BigDataCloud returns the data directly, no error field to check
            // Transform to match expected format
            const transformedData = {
              address: {
                city: data.city || data.locality,
                town: data.town,
                village: data.village,
                municipality: data.municipality,
                county: data.county,
                state: data.principalSubdivision,
                state_district: data.principalSubdivision,
                country: data.countryName,
              },
              display_name: data.displayName || \`\${data.city || data.locality || ''}, \${data.principalSubdivision || ''}\`.trim(),
            };
            
            return new Response(JSON.stringify(transformedData), {
              headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
              },
            });
          } catch (fetchError) {
            // Re-throw to be caught by outer catch block
            throw fetchError;
          }
        } else {
          // Standard handling for other APIs (forecast, geocoding, etc.)
          try {
            // Create cache key from the full request URL
            const cacheKey = new Request(targetUrl);
            
            // Try to get from cache first (only for forecast and geocoding)
            if (apiPath.startsWith('forecast') || apiPath.startsWith('geocoding')) {
              const cachedResponse = await caches.default.match(cacheKey);
              if (cachedResponse) {
                // Clone the cached response and add CORS headers
                const cachedData = await cachedResponse.json();
                return new Response(JSON.stringify(cachedData), {
                  headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*',
                    'X-Cache': 'HIT',
                  },
                });
              }
            }
            
            // Add timeout for long-running requests (30 seconds)
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000);
            
            if (!fetchOptions) {
              fetchOptions = {};
            }
            fetchOptions.signal = controller.signal;
            
            // Add User-Agent header for Open-Meteo to help with rate limiting
            if (apiPath.startsWith('forecast') || apiPath.startsWith('geocoding')) {
              if (!fetchOptions.headers) {
                fetchOptions.headers = new Headers();
              }
              // Use a descriptive User-Agent to help Open-Meteo identify the app
              fetchOptions.headers.set('User-Agent', 'WeatherApp/1.0 (https://weather-app.jackanglim3.workers.dev)');
            }
            
            // Retry logic for rate limits (max 2 retries)
            let response;
            let retries = 0;
            const maxRetries = 2;
            
            while (retries <= maxRetries) {
              response = await fetch(targetUrl, fetchOptions);
              
              // If we get a 429, check for Retry-After header and wait accordingly
              if (response.status === 429 && retries < maxRetries) {
                const retryAfter = response.headers.get('Retry-After');
                const waitTime = retryAfter 
                  ? parseInt(retryAfter, 10) * 1000 
                  : Math.pow(2, retries) * 1000; // 1s, 2s, 4s
                console.log(\`Rate limited, retrying in \${waitTime}ms... (attempt \${retries + 1}/\${maxRetries})\`);
                await new Promise(resolve => setTimeout(resolve, Math.min(waitTime, 10000))); // Max 10s wait
                retries++;
                continue;
              }
              
              break; // Success or non-retryable error
            }
            
            clearTimeout(timeoutId);
            
            // Handle rate limiting (429) after retries exhausted
            if (response.status === 429) {
              // Check for Retry-After header to provide specific wait time
              const retryAfter = response.headers.get('Retry-After');
              let waitMessage = 'Rate limit exceeded. ';
              if (retryAfter) {
                const waitSeconds = parseInt(retryAfter, 10);
                const waitMinutes = Math.ceil(waitSeconds / 60);
                waitMessage += \`Please wait \${waitMinutes} minute\${waitMinutes > 1 ? 's' : ''} and try again.\`;
              } else {
                waitMessage += 'Please wait 1-2 minutes and try again.';
              }
              
              return new Response(JSON.stringify({ 
                error: true, 
                reason: waitMessage
              }), {
                status: 429,
                headers: {
                  'Content-Type': 'application/json',
                  'Access-Control-Allow-Origin': '*',
                },
              });
            }
            
            if (!response.ok) {
              const errorText = await response.text();
              console.error(\`API error (\${response.status}) for \${targetUrl}:\`, errorText.substring(0, 200));
              throw new Error(\`HTTP error! status: \${response.status}\`);
            }
            
            // Try to parse as JSON
            let data;
            let text;
            try {
              text = await response.text();
              // Check if response is empty
              if (!text || text.trim().length === 0) {
                throw new Error('Empty response from API');
              }
              data = JSON.parse(text);
            } catch (parseError) {
              const contentType = response.headers.get('content-type');
              console.error('Failed to parse JSON response. Content-Type:', contentType, 'Response preview:', text?.substring(0, 200));
              
              // If we got a 429 but it's not JSON, return a proper error
              if (response.status === 429) {
                return new Response(JSON.stringify({ 
                  error: true, 
                  reason: 'Rate limit exceeded. Please try again in a few moments.' 
                }), {
                  status: 429,
                  headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*',
                  },
                });
              }
              
              throw new Error(\`Invalid response format: \${parseError.message}\`);
            }
            
            // Cache successful responses (only for forecast and geocoding)
            if (apiPath.startsWith('forecast') || apiPath.startsWith('geocoding')) {
              // Determine cache duration based on API type
              const cacheSeconds = apiPath.startsWith('forecast') ? 600 : 3600; // 10 min for forecast, 1 hour for geocoding
              
              // Create a response with cache headers
              const cacheResponse = new Response(JSON.stringify(data), {
                headers: {
                  'Content-Type': 'application/json',
                  'Cache-Control': \`public, max-age=\${cacheSeconds}\`,
                },
              });
              
              // Store in cache
              ctx.waitUntil(caches.default.put(cacheKey, cacheResponse.clone()));
            }
            
            return new Response(JSON.stringify(data), {
              headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
                'X-Cache': 'MISS',
              },
            });
          } catch (fetchError) {
            if (fetchError.name === 'AbortError') {
              console.error('Request timeout for', targetUrl);
              throw new Error('Request timeout');
            }
            console.error('Fetch error for', targetUrl, ':', fetchError.message);
            throw fetchError;
          }
        }
      } catch (error) {
        console.error('API proxy error:', error);
        return new Response(JSON.stringify({ error: true, reason: error.message }), {
          status: 500,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
        });
      }
    }
    
    return new Response('Not Found', { status: 404 });
  },
};
`;

// Write the built worker file
fs.writeFileSync(path.join(__dirname, 'src', 'index.js'), workerContent);
console.log('Build complete! Generated src/index.js');

